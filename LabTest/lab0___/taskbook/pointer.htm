<!-- Programming Taskbook 4.4 | Copyright (c) M. Abramyan, 1998-2005 -->
<html><head><meta http-equiv="pragma" content="no-cache"><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>Programming Taskbook 4.4 | Указатели и динамические структуры данных</title>
</head><body vlink="#003366" link="#003366"><style>
H1{font-family:"Arial";font-size:20pt;text-indent:0;margin-top:10; margin-right:10; margin-bottom:0; margin-left:10;}
H2{font-family:"Arial";font-size:16pt;text-indent:0;margin: 20 10 0 10;}
H3{font-family:"Arial";font-size:12pt;text-indent:0;margin: 20 10 0 10;}
P{font-family:"Times New Roman";font-size:12pt;text-indent:0;margin-top:0; margin-right:10; margin-bottom:0; margin-left:10;}
center{font-family:"Times New Roman";font-size:12pt;}
TABLE{margin-top:0; margin-bottom:0;}
TD{font-family:"Times New Roman";font-size:12pt;}
LI{font-family:"Times New Roman";font-size:12pt;}
UL{font-family:"Times New Roman";font-size:12pt;}
P.tsk{text-align:left;text-indent:-50;margin-top:5; margin-left:60;}
P.hnt{text-align:left;margin-left:60;}
P.hntc{text-align:left;margin-left:60;}
P.hntq{text-align:left;margin-left: 60;}
P.cmt{text-align:left;margin-top:5;}
P.ttt{text-align:left;}
P.cnt{text-align:center;}
P.qte{text-align:left;margin-left:120;margin-top:0;margin-bottom:0;}
blockquote{font-family:"Times New Roman";text-align:left;margin-left:100;margin-top:0; margin-bottom:0;}
P.cmtc{text-align:left;}
P.cmtq{text-align:left;}
SUB{font-family:"Times New Roman";font-size:8pt;}
SUP{font-family:"Times New Roman";font-size:8pt;}
P.foot{text-align:right;font-size:8pt;margin-right:0;}
</style>
<script language="javascript" src="back.js">
</script>
<font face="Arial" size=+3><b>Programming Taskbook 4</b><br></font>
<font face="Arial" size=+1>Электронный задачник по программированию</font>
<div align=right><font size = -1>&copy;&nbsp;&nbsp;М.&nbsp;Э.&nbsp;Абрамян,&nbsp;1998&#150;2005</font></div>
<hr noshade>
<div align=center><font size=-1>
[<a href="index.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/index.htm">Общее&nbsp;описание</a>] [<a href="remarks.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/remarks.htm">Предварительные&nbsp;замечания</a>] [<a href="begin.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/begin.htm">Ввод&nbsp;и&nbsp;вывод&nbsp;данных,&nbsp;оператор&nbsp;присваивания</a>] [<a href="integer.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/integer.htm">Целые&nbsp;числа</a>] [<a href="boolean.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/boolean.htm">Логические&nbsp;выражения</a>] [<a href="if.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/if.htm">Условный&nbsp;оператор</a>] [<a href="case.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/case.htm">Оператор&nbsp;выбора</a>] [<a href="for.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/for.htm">Цикл&nbsp;с&nbsp;параметром</a>] [<a href="while.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/while.htm">Цикл&nbsp;с&nbsp;условием</a>] [<a href="series.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/series.htm">Последовательности</a>] [<a href="proc.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/proc.htm">Процедуры&nbsp;и&nbsp;функции</a>] [<a href="minmax.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/minmax.htm">Минимумы&nbsp;и&nbsp;максимумы</a>] [<a href="array.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/array.htm">Одномерные&nbsp;массивы</a>] [<a href="matrix.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/matrix.htm">Двумерные&nbsp;массивы&nbsp;(матрицы)</a>] [<a href="string.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/string.htm">Символы&nbsp;и&nbsp;строки</a>] [<a href="file.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/file.htm">Двоичные&nbsp;(типизированные)&nbsp;файлы</a>] [<a href="text.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/text.htm">Текстовые&nbsp;файлы</a>] [<a href="param.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/param.htm">Составные&nbsp;типы&nbsp;данных&nbsp;в&nbsp;процедурах&nbsp;и&nbsp;функциях</a>] [<a href="recur.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/recur.htm">Рекурсия</a>] [<b>Указатели&nbsp;и&nbsp;динамические&nbsp;структуры&nbsp;данных</b>] [<a href="demo.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/demo.htm">Задания&nbsp;демо-версии</a>]
</font></div><hr noshade><div align=right><font size=-1>Стиль: [<a href="pointerd.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/pointerd.htm">DOS-программа</a>] [<a href="pointerw.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/pointerw.htm">Windows-программа</a>] [<b>Книга</b>]</font></div>

<p class="cmt"><h1>Указатели и динамические структуры данных</h1></p>
<p class="cmt">Данная группа не&nbsp;включена в&nbsp;варианты задачника для языков Visual Basic и&nbsp;C#.</p>
<p class="cmt">Все&nbsp;числа, упоминаемые в&nbsp;заданиях данной группы, являются <i>целыми</i>. Все&nbsp;указатели имеют тип PNode и&nbsp;указывают на&nbsp;записи типа TNode. Типы PNode и&nbsp;TNode описаны в&nbsp;варианте задачника для&nbsp;языка Pascal следующим образом: </p><p class="qte">type<br> &nbsp; &nbsp;PNode = ^TNode;<br> &nbsp; &nbsp;TNode = record<br> &nbsp; &nbsp; &nbsp; &nbsp;Data: integer;<br> &nbsp; &nbsp; &nbsp; &nbsp;Next: PNode;<br> &nbsp; &nbsp; &nbsp; &nbsp;Prev: PNode;<br> &nbsp; &nbsp;end;</p>
<p class="cmt">Аналогично описываются эти типы в&nbsp;варианте задачника для&nbsp;языка&nbsp;С: </p><p class="qte">struct TNode<br>{<br> &nbsp; &nbsp;int Data;<br> &nbsp; &nbsp;TNode* Next;<br> &nbsp; &nbsp;TNode* Prev;<br>};<br><br>typedef TNode* PNode;</p>
<p class="cmt">В&nbsp;заданиях на&nbsp;стеки и&nbsp;очереди (Pointer1&#150;Pointer28) при&nbsp;работе с&nbsp;записями типа TNode используются только поля Data и&nbsp;Next (см.&nbsp;задание Pointer1); в&nbsp;заданиях на двусвязные спискиа (Pointer29&#150;Pointer80) используются все&nbsp;поля записи TNode (см.&nbsp;задание Pointer29).</p>
<p class="cmt">Так как переменные типа &#171;указатель&#187; предназначены для&nbsp;хранения <i>адресов</i>, в&nbsp;формулировках заданий слова &#171;указатель&#187; (на&nbsp;элемент данных) и &#171;адрес&#187; (элемента данных) используются как&nbsp;синонимы.</p>
<p class="cmt">Для&nbsp;обозначения нулевого указателя в&nbsp;формулировках заданий используется имя&nbsp;nil.</p>
<p class="cmt"><h2>Стеки</h2></p>
<p class="tsk"><font face="Arial">Pointer1</font>. Дан адрес&nbsp;<i>P</i><sub>1</sub> записи типа TNode, содержащей поле Data (целого типа) и&nbsp;поле Next (типа PNode&nbsp;&#151; указателя на&nbsp;TNode). Эта&nbsp;запись связана полем Next со&nbsp;следующей записью того&nbsp;же типа. Вывести значения полей Data обеих записей, а&nbsp;также адрес&nbsp;<i>P</i><sub>2</sub> следующей записи.</p>
<p class="tsk"><font face="Arial">Pointer2*</font>. Дан адрес&nbsp;<i>P</i><sub>1</sub> записи типа TNode. Эта&nbsp;запись связана полем Next со&nbsp;следующей записью того&nbsp;же типа, она, в&nbsp;свою очередь,&nbsp;&#151; со&nbsp;следующей, и&nbsp;так&nbsp;далее до&nbsp;записи, поле Next которой равно&nbsp;nil (таким образом, возникает <i>цепочка</i> связанных записей). Вывести значения полей Data для&nbsp;всех элементов цепочки, <i>длину цепочки</i> (то&nbsp;есть число ее&nbsp;элементов) и&nbsp;адрес ее&nbsp;последнего элемента.</p>
<p class="cmt">В заданиях Pointer3&#150;Pointer13 структура <i>&#171;стек&#187;</i> (stack) моделируется цепочкой связанных узлов-записей типа TNode (см.&nbsp;задание Pointer2). Поле Next последнего элемента цепочки равно&nbsp;nil. <i>Вершиной стека</i> (top) считается первый элемент цепочки. Для&nbsp;доступа к&nbsp;стеку используется указатель на&nbsp;его&nbsp;вершину (для&nbsp;пустого стека данный указатель полагается равным&nbsp;nil). <i>Значением</i> элемента стека считается значение его&nbsp;поля&nbsp;Data.</p>
<p class="tsk"><font face="Arial">Pointer3*</font>. Дано число&nbsp;<i>D</i> и&nbsp;указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;вершину непустого стека. Добавить элемент со&nbsp;значением&nbsp;<i>D</i> в&nbsp;стек и&nbsp;вывести адрес&nbsp;<i>P</i><sub>2</sub> новой вершины стека.</p>
<p class="tsk"><font face="Arial">Pointer4</font>. Дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и&nbsp;набор из&nbsp;<i>N</i>&nbsp;чисел. Создать стек, содержащий исходные числа (последнее число будет вершиной стека), и&nbsp;вывести указатель на&nbsp;его&nbsp;вершину.</p>
<p class="tsk"><font face="Arial">Pointer5*</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на вершину непустого стека. Извлечь из&nbsp;стека первый (верхний) элемент и&nbsp;вывести его&nbsp;значение&nbsp;<i>D</i>, а&nbsp;также адрес&nbsp;<i>P</i><sub>2</sub> новой вершины стека. Если после извлечения элемента стек окажется пустым, то&nbsp;положить <i>P</i><sub>2</sub>&nbsp;=&nbsp;nil. После извлечения элемента из&nbsp;стека освободить память, занимаемую этим элементом.</p>
<p class="tsk"><font face="Arial">Pointer6</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;вершину стека, содержащего не&nbsp;менее десяти элементов. Извлечь из&nbsp;стека первые девять элементов и&nbsp;вывести их&nbsp;значения. Вывести также адрес новой вершины стека. После извлечения элементов из&nbsp;стека освобождать память, которую они занимали.</p>
<p class="tsk"><font face="Arial">Pointer7</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;вершину стека (если стек пуст, то&nbsp;<i>P</i><sub>1</sub>&nbsp;=&nbsp;nil). Извлечь из&nbsp;стека все&nbsp;элементы и&nbsp;вывести их&nbsp;значения. Вывести также количество извлеченных элементов&nbsp;<i>N</i> (для&nbsp;пустого стека вывести&nbsp;0). После извлечения элементов из&nbsp;стека освобождать память, которую они занимали.</p>
<p class="tsk"><font face="Arial">Pointer8*</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;вершины двух непустых стеков. Переместить все&nbsp;элементы из&nbsp;первого стека во&nbsp;второй (в&nbsp;результате элементы первого стека будут располагаться во&nbsp;втором стеке в&nbsp;порядке, обратном исходному) и&nbsp;вывести адрес новой вершины второго стека. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer9</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;вершины двух непустых стеков. Перемещать элементы из&nbsp;первого стека во&nbsp;второй, пока значение вершины первого стека не&nbsp;станет четным (перемещенные элементы первого стека будут располагаться во&nbsp;втором стеке в&nbsp;порядке, обратном исходному). Если в&nbsp;первом стеке нет&nbsp;элементов с&nbsp;четными значениями, то&nbsp;переместить из&nbsp;первого стека во&nbsp;второй все&nbsp;элементы. Вывести адреса новых вершин первого и&nbsp;второго стека (если первый стек окажется пустым, то&nbsp;вывести для него константу nil). Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer10</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;вершину непустого стека. Создать два&nbsp;новых стека, переместив в&nbsp;первый из&nbsp;них все&nbsp;элементы исходного стека с&nbsp;четными значениями, а&nbsp;во&nbsp;второй&nbsp;&#151; с&nbsp;нечетными (элементы в&nbsp;новых стеках будут располагаться в&nbsp;порядке, обратном исходному; один из&nbsp;этих стеков может оказаться пустым). Вывести адреса вершин полученных стеков (для&nbsp;пустого стека вывести&nbsp;nil). Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer11*</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;вершину стека (если стек пуст, то&nbsp;<i>P</i><sub>1</sub>&nbsp;=&nbsp;nil). Также дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и&nbsp;набор из&nbsp;<i>N</i>&nbsp;чисел. Описать тип TStack&nbsp;&#151; запись с&nbsp;одним полем Top типа PNode (поле указывает на&nbsp;<i>вершину стека</i>)&nbsp;&#151; и&nbsp;процедуру Push(<i>S</i>,&nbsp;<i>D</i>), которая добавляет в&nbsp;стек&nbsp;<i>S</i> новый элемент со&nbsp;значением&nbsp;<i>D</i> (<i>S</i>&nbsp;&#151; входной и&nbsp;выходной параметр типа TStack, <i>D</i>&nbsp;&#151; входной параметр целого типа). С&nbsp;помощью процедуры Push добавить в&nbsp;исходный стек данный набор чисел (последнее число будет вершиной стека) и&nbsp;вывести адрес новой вершины стека.</p>
<p class="tsk"><font face="Arial">Pointer12</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;вершину стека, содержащего не&nbsp;менее пяти элементов. Используя тип TStack (см.&nbsp;задание Pointer11), описать функцию Pop(<i>S</i>) целого типа, которая извлекает из&nbsp;стека&nbsp;<i>S</i> первый (верхний) элемент, возвращает его значение и&nbsp;освобождает память, которую занимал извлеченный элемент (<i>S</i>&nbsp;&#151; входной и&nbsp;выходной параметр типа TStack). С&nbsp;помощью функции Pop извлечь из&nbsp;исходного стека пять&nbsp;элементов и&nbsp;вывести их&nbsp;значения. Вывести также указатель на&nbsp;новую вершину стека (если результирующий стек окажется пустым, то этот указатель должен быть равен&nbsp;nil).</p>
<p class="tsk"><font face="Arial">Pointer13</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;вершину стека. Используя тип TStack (см.&nbsp;задание Pointer11), описать функции StackIsEmpty(<i>S</i>) логического типа (возвращает True, если стек&nbsp;<i>S</i> пуст, и&nbsp;False в&nbsp;противном случае) и&nbsp;Peek(<i>S</i>) целого типа (возвращает значение вершины непустого стека&nbsp;<i>S</i>, не&nbsp;удаляя&nbsp;ее из&nbsp;стека). В&nbsp;обеих функциях переменная&nbsp;<i>S</i> является входным параметром типа TStack. С&nbsp;помощью этих&nbsp;функций, а&nbsp;также функции Pop из&nbsp;задания Pointer12, извлечь из&nbsp;исходного стека пять&nbsp;элементов (или&nbsp;все содержащиеся в&nbsp;нем элементы, если&nbsp;их менее пяти) и&nbsp;вывести их&nbsp;значения. Вывести также значение функции StackIsEmpty для&nbsp;результирующего стека и, если&nbsp;результирующий стек не&nbsp;является пустым, значение и&nbsp;адрес его&nbsp;новой вершины.</p>
<p class="cmt"><h2>Очереди</h2></p>
<p class="cmt">В&nbsp;заданиях Pointer14&#150;Pointer28 структура <i>&#171;очередь&#187;</i> (queue) моделируется цепочкой связанных узлов-записей типа TNode (см.&nbsp;задание Pointer2). Поле Next последнего элемента цепочки равно&nbsp;nil. <i>Началом очереди</i> (&#171;головой&#187;, head)  считается первый элемент цепочки, <i>концом</i> (&#171;хвостом&#187;, tail)&nbsp;&#151; ее&nbsp;последний элемент. Для&nbsp;возможности быстрого добавления в&nbsp;конец очереди нового элемента удобно хранить, помимо указателя на&nbsp;начало очереди, также и&nbsp;указатель на&nbsp;ее&nbsp;конец. В&nbsp;случае пустой очереди указатели на&nbsp;ее&nbsp;начало и&nbsp;конец полагаются равными&nbsp;nil. Как и&nbsp;для&nbsp;стека, <i>значением</i> элемента очереди считается значение его&nbsp;поля&nbsp;Data.</p>
<p class="tsk"><font face="Arial">Pointer14</font>. Дан набор из&nbsp;10&nbsp;чисел. Создать очередь, содержащую данные числа в&nbsp;указанном порядке (первое число будет размещаться в&nbsp;начале очереди, последнее&nbsp;&#151; в&nbsp;конце), и&nbsp;вывести указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;начало и&nbsp;конец очереди.</p>
<p class="tsk"><font face="Arial">Pointer15</font>. Дан набор из&nbsp;10&nbsp;чисел. Создать две&nbsp;очереди: первая должна содержать числа из&nbsp;исходного набора с&nbsp;нечетными номерами (1, 3,&nbsp;&#133;,&nbsp;9), а&nbsp;вторая&nbsp;&#151; с&nbsp;четными (2, 4,&nbsp;&#133;,&nbsp;10); порядок чисел в&nbsp;каждой очереди должен совпадать с&nbsp;порядком чисел в&nbsp;исходном наборе. Вывести указатели на&nbsp;начало и&nbsp;конец первой, а&nbsp;затем второй очереди.</p>
<p class="tsk"><font face="Arial">Pointer16</font>. Дан набор из 10&nbsp;чисел. Создать две&nbsp;очереди: первая должна содержать все нечетные, а&nbsp;вторая&nbsp;&#151; все четные числа из&nbsp;исходного набора (порядок чисел в&nbsp;каждой очереди должен совпадать с&nbsp;порядком чисел в&nbsp;исходном наборе). Вывести указатели на&nbsp;начало и&nbsp;конец первой, а&nbsp;затем второй очереди (одна из&nbsp;очередей может оказаться пустой; в&nbsp;этом случае вывести для&nbsp;нее две константы&nbsp;nil).</p>
<p class="tsk"><font face="Arial">Pointer17</font>. Дано число&nbsp;<i>D</i> и&nbsp;указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;начало и&nbsp;конец очереди (если очередь является пустой, то <i>P</i><sub>1</sub>&nbsp;=&nbsp;<i>P</i><sub>2</sub>&nbsp;=&nbsp;nil). Добавить элемент со&nbsp;значением&nbsp;<i>D</i> в&nbsp;конец очереди и&nbsp;вывести новые адреса начала и&nbsp;конца очереди.</p>
<p class="tsk"><font face="Arial">Pointer18</font>. Дано число&nbsp;<i>D</i> и&nbsp;указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;начало и&nbsp;конец очереди, содержащей не&nbsp;менее двух&nbsp;элементов. Добавить элемент со&nbsp;значением&nbsp;<i>D</i> в&nbsp;конец очереди и&nbsp;извлечь из&nbsp;очереди первый (начальный) элемент. Вывести значение извлеченного элемента и&nbsp;новые адреса начала и&nbsp;конца очереди. После извлечения элемента из&nbsp;очереди освободить память, занимаемую этим элементом.</p>
<p class="tsk"><font face="Arial">Pointer19</font>. Дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и&nbsp;указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;начало и&nbsp;конец непустой очереди. Извлечь из&nbsp;очереди <i>N</i>&nbsp;начальных элементов и&nbsp;вывести их&nbsp;значения (если очередь содержит менее <i>N</i>&nbsp;элементов, то&nbsp;извлечь все ее&nbsp;элементы). Вывести также новые адреса начала и&nbsp;конца очереди (для&nbsp;пустой очереди дважды вывести nil). После извлечения элементов из&nbsp;очереди освобождать память, которую они занимали.</p>
<p class="tsk"><font face="Arial">Pointer20</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;начало и&nbsp;конец непустой очереди. Извлекать из&nbsp;очереди элементы, пока&nbsp;значение начального элемента очереди не&nbsp;станет четным, и&nbsp;выводить значения извлеченных элементов (если очередь не&nbsp;содержит элементов с&nbsp;четными значениями, то&nbsp;извлечь все ее&nbsp;элементы). Вывести также новые адреса начала и&nbsp;конца очереди (для&nbsp;пустой очереди дважды вывести nil). После извлечения элементов из&nbsp;очереди освобождать память, которую они занимали.</p>
<p class="tsk"><font face="Arial">Pointer21</font>. Даны две очереди; адреса начала и&nbsp;конца первой равны&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub>, а&nbsp;второй&nbsp;&#151; <i>P</i><sub>3</sub> и&nbsp;<i>P</i><sub>4</sub> (если&nbsp;очередь является пустой, то&nbsp;соответствующие адреса равны&nbsp;nil). Переместить все&nbsp;элементы первой очереди (в&nbsp;порядке от&nbsp;начала к&nbsp;концу) в&nbsp;конец второй очереди и&nbsp;вывести новые адреса начала и&nbsp;конца второй очереди. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer22</font>. Дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и&nbsp;две&nbsp;непустые очереди; адреса начала и&nbsp;конца первой равны <i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub>, а&nbsp;второй&nbsp;&#151; <i>P</i><sub>3</sub> и&nbsp;<i>P</i><sub>4</sub>. Переместить <i>N</i>&nbsp;начальных элементов первой очереди в&nbsp;конец второй очереди. Если первая очередь содержит менее <i>N</i>&nbsp;элементов, то&nbsp;переместить из&nbsp;первой очереди во&nbsp;вторую все&nbsp;элементы. Вывести новые адреса начала и&nbsp;конца первой, а&nbsp;затем второй очереди (для&nbsp;пустой очереди дважды вывести&nbsp;nil). Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer23</font>. Даны две непустые очереди; адреса начала и&nbsp;конца первой равны&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub>, а&nbsp;второй&nbsp;&#151; <i>P</i><sub>3</sub> и&nbsp;<i>P</i><sub>4</sub>. Перемещать элементы из&nbsp;начала первой очереди в&nbsp;конец второй, пока&nbsp;значение начального элемента первой очереди не&nbsp;станет четным (если первая очередь не&nbsp;содержит четных элементов, то&nbsp;переместить из&nbsp;первой очереди во&nbsp;вторую все&nbsp;элементы). Вывести новые адреса начала и&nbsp;конца первой, а&nbsp;затем второй очереди (для&nbsp;пустой очереди дважды вывести&nbsp;nil). Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer24</font>. Даны две непустые очереди; адреса начала и&nbsp;конца первой равны&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub>, а&nbsp;второй&nbsp;&#151; <i>P</i><sub>3</sub> и&nbsp;<i>P</i><sub>4</sub>. Очереди содержат одинаковое количество элементов. Объединить очереди в&nbsp;одну, в&nbsp;которой элементы исходных очередей чередуются (начиная с&nbsp;первого элемента первой очереди). Вывести указатели на&nbsp;начало и&nbsp;конец полученной очереди. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer25</font>. Даны две непустые очереди; адреса начала и&nbsp;конца первой равны&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub>, а&nbsp;второй&nbsp;&#151; <i>P</i><sub>3</sub> и&nbsp;<i>P</i><sub>4</sub>. Элементы каждой из&nbsp;очередей упорядочены по&nbsp;возрастанию (в&nbsp;направлении от&nbsp;начала очереди к&nbsp;концу). Объединить очереди в&nbsp;одну с&nbsp;сохранением упорядоченности элементов. Вывести указатели на&nbsp;начало и&nbsp;конец полученной очереди. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer26</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;начало и&nbsp;конец очереди (если очередь является пустой, то&nbsp;<i>P</i><sub>1</sub>&nbsp;=&nbsp;<i>P</i><sub>2</sub>&nbsp;=&nbsp;nil). Также дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и&nbsp;набор из&nbsp;<i>N</i>&nbsp;чисел. Описать тип TQueue&nbsp;&#151; запись с&nbsp;двумя полями типа PNode: Head (<i>начало очереди</i>) и&nbsp;Tail (<i>конец очереди</i>)&nbsp;&#151; и&nbsp;процедуру Enqueue(<i>Q</i>,&nbsp;<i>D</i>), которая добавляет в&nbsp;конец очереди&nbsp;<i>Q</i> новый элемент со&nbsp;значением&nbsp;<i>D</i> (<i>Q</i>&nbsp;&#151; входной и&nbsp;выходной параметр типа TQueue, <i>D</i>&nbsp;&#151; входной параметр целого типа). С&nbsp;помощью процедуры Enqueue добавить в&nbsp;исходную очередь данный набор чисел и&nbsp;вывести новые адреса ее&nbsp;начала и&nbsp;конца.</p>
<p class="tsk"><font face="Arial">Pointer27</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;начало и&nbsp;конец очереди, содержащей не&nbsp;менее пяти элементов. Используя тип TQueue (см. задание Pointer26), описать функцию Dequeue(<i>Q</i>) целого типа, которая извлекает из&nbsp;очереди первый (начальный) элемент, возвращает его&nbsp;значение и&nbsp;освобождает память, занимаемую извлеченным элементом (<i>Q</i>&nbsp;&#151; входной и&nbsp;выходной параметр типа TQueue). С&nbsp;помощью функции Dequeue извлечь из&nbsp;исходной очереди пять&nbsp;начальных элементов и&nbsp;вывести их&nbsp;значения. Вывести также адреса начала и&nbsp;конца результирующей очереди (если&nbsp;очередь окажется пустой, то&nbsp;эти адреса должны быть равны&nbsp;nil).</p>
<p class="tsk"><font face="Arial">Pointer28</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;начало и&nbsp;конец очереди. Используя тип TQueue (см. задание Pointer26), описать функцию QueueIsEmpty(<i>Q</i>) логического типа, которая возвращает True, если очередь&nbsp;<i>Q</i> пуста, и&nbsp;False в&nbsp;противном случае (<i>Q</i>&nbsp;&#151; входной параметр типа TQueue). Используя эту функцию для&nbsp;проверки состояния очереди, а&nbsp;также функцию Dequeue из&nbsp;задания Pointer27, извлечь из&nbsp;исходной очереди пять&nbsp;начальных элементов (или&nbsp;все содержащиеся в&nbsp;ней элементы, если их&nbsp;менее пяти) и&nbsp;вывести их&nbsp;значения. Вывести также значение функции QueueIsEmpty для&nbsp;полученной очереди и&nbsp;новые адреса ее&nbsp;начала и&nbsp;конца.</p>
<p class="cmt"><h2>Двусвязные списки</h2></p>
<p class="tsk"><font face="Arial">Pointer29</font>. Дан адрес <i>P</i><sub>2</sub> записи типа TNode, содержащей поле Data (целого типа) и&nbsp;поля Prev и&nbsp;Next (типа PNode&nbsp;&#151; указателя на&nbsp;TNode). Эта запись связана полями Prev и&nbsp;Next соответственно с&nbsp;предыдущей и&nbsp;последующей записью того&nbsp;же типа. Вывести значения полей Data предыдущей и&nbsp;последующей записи, а&nbsp;также адреса&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>3</sub> предыдущей и&nbsp;последующей записи.</p>
<p class="tsk"><font face="Arial">Pointer30*</font>. Дан указатель <i>P</i><sub>1</sub> на&nbsp;начало непустой цепочки элементов-записей типа TNode, связанных между собой с&nbsp;помощью поля Next. Используя поле Prev записи TNode, преобразовать исходную (<i>односвязную</i>) цепочку в&nbsp;<i>двусвязную</i>, в&nbsp;которой каждый элемент связан не&nbsp;только с&nbsp;последующим элементом (с&nbsp;помощью поля Next), но&nbsp;и&nbsp;с&nbsp;предыдущим (с&nbsp;помощью поля Prev). Поле Prev первого элемента положить равным&nbsp;nil. Вывести указатель на&nbsp;последний элемент преобразованной цепочки.</p>
<p class="cmt">В&nbsp;заданиях Pointer31&#150;Pointer69 структура <i>&#171;двусвязный список&#187;</i> (doubly linked list) моделируется цепочкой узлов-записей типа TNode, связанных как с&nbsp;предыдущим, так и&nbsp;с&nbsp;последующим узлом (см.&nbsp;задание Pointer30). Поле Next последнего элемента цепочки и&nbsp;поле Prev первого элемента цепочки равны&nbsp;nil. Для&nbsp;доступа к&nbsp;любому элементу двусвязного списка достаточно иметь указатель на&nbsp;один из&nbsp;его&nbsp;элементов, однако для&nbsp;ускорения операций со&nbsp;списком обычно хранят три&nbsp;указателя: на&nbsp;<i>первый</i> элемент списка (first), на&nbsp;его&nbsp;<i>последний</i> элемент (last) и&nbsp;на&nbsp;<i>текущий</i> элемент (current). Для&nbsp;пустого списка все эти&nbsp;указатели полагаются равными&nbsp;nil. Как&nbsp;в&nbsp;случае стека и&nbsp;очереди, <i>значением</i> элемента списка считается значение его&nbsp;поля&nbsp;Data.</p>
<p class="tsk"><font face="Arial">Pointer31</font>. Дан указатель&nbsp;<i>P</i><sub>0</sub> на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Вывести число&nbsp;<i>N</i>&nbsp;&#151; количество элементов в&nbsp;списке, а&nbsp;также указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;первый и&nbsp;последний элементы списка.</p>
<p class="tsk"><font face="Arial">Pointer32</font>. Даны числа&nbsp;<i>D</i><sub>1</sub> и&nbsp;<i>D</i><sub>2</sub> и&nbsp;указатель&nbsp;<i>P</i><sub>0</sub> на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Добавить в&nbsp;начало списка новый элемент со&nbsp;значением&nbsp;<i>D</i><sub>1</sub>, а&nbsp;в&nbsp;конец&nbsp;&#151; новый элемент со&nbsp;значением&nbsp;<i>D</i><sub>2</sub>. Вывести адреса первого и&nbsp;последнего элементов полученного списка.</p>
<p class="tsk"><font face="Arial">Pointer33</font>. Дано число&nbsp;<i>D</i> и&nbsp;указатель&nbsp;<i>P</i><sub>0</sub> на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Вставить перед данным элементом списка новый элемент со&nbsp;значением&nbsp;<i>D</i> и&nbsp;вывести указатель на&nbsp;добавленный элемент списка.</p>
<p class="tsk"><font face="Arial">Pointer34</font>. Дано число&nbsp;<i>D</i> и&nbsp;указатель&nbsp;<i>P</i><sub>0</sub> на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Вставить после данного элемента списка новый элемент со&nbsp;значением&nbsp;<i>D</i> и&nbsp;вывести указатель на&nbsp;добавленный элемент списка.</p>
<p class="tsk"><font face="Arial">Pointer35</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;первый и&nbsp;последний элементы двусвязного списка, содержащего не&nbsp;менее двух элементов. Продублировать в&nbsp;списке первый и&nbsp;последний элементы (новые элементы добавлять перед существующими элементами с&nbsp;такими же&nbsp;значениями) и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка.</p>
<p class="tsk"><font face="Arial">Pointer36</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;первый и&nbsp;последний элементы двусвязного списка, содержащего не&nbsp;менее двух элементов. Продублировать в&nbsp;списке первый и&nbsp;последний элементы (новые элементы добавлять после существующих элементов с&nbsp;такими же&nbsp;значениями) и&nbsp;вывести указатель на&nbsp;последний элемент преобразованного списка.</p>
<p class="tsk"><font face="Arial">Pointer37</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;первый элемент непустого двусвязного списка. Продублировать в&nbsp;списке все&nbsp;элементы с&nbsp;нечетными номерами (новые элементы добавлять перед существующими элементами с&nbsp;такими же&nbsp;значениями) и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка.</p>
<p class="tsk"><font face="Arial">Pointer38</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;первый элемент непустого двусвязного списка. Продублировать в&nbsp;списке все&nbsp;элементы с&nbsp;нечетными номерами (новые элементы добавлять после существующих элементов с&nbsp;такими же&nbsp;значениями) и&nbsp;вывести указатель на&nbsp;последний элемент преобразованного списка.</p>
<p class="tsk"><font face="Arial">Pointer39</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;первый элемент непустого двусвязного списка. Продублировать в&nbsp;списке все&nbsp;элементы с&nbsp;нечетными значениями (новые элементы добавлять перед существующими элементами с&nbsp;такими&nbsp;же значениями) и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка.</p>
<p class="tsk"><font face="Arial">Pointer40</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;первый элемент непустого двусвязного списка. Продублировать в&nbsp;списке все&nbsp;элементы с&nbsp;нечетными значениями (новые элементы добавлять после существующих элементов с&nbsp;такими&nbsp;же значениями) и&nbsp;вывести указатель на&nbsp;последний элемент преобразованного списка.</p>
<p class="tsk"><font face="Arial">Pointer41</font>. Дан указатель&nbsp;<i>P</i><sub>0</sub> на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Удалить из&nbsp;списка данный элемент и&nbsp;вывести два указателя: на&nbsp;элемент, предшествующий удаленному, и&nbsp;на&nbsp;элемент, следующий за&nbsp;удаленным (один или&nbsp;оба этих элемента могут отсутствовать; для&nbsp;отсутствующих элементов выводить&nbsp;nil). После удаления элемента из&nbsp;списка освободить память, занимаемую этим&nbsp;элементом.</p>
<p class="tsk"><font face="Arial">Pointer42</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;первый элемент двусвязного списка, содержащего не&nbsp;менее двух&nbsp;элементов. Удалить из&nbsp;списка все&nbsp;элементы с&nbsp;нечетными номерами и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка. После удаления элементов из&nbsp;списка освобождать память, которую они занимали.</p>
<p class="tsk"><font face="Arial">Pointer43</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;первый элемент непустого двусвязного списка. Удалить из&nbsp;списка все&nbsp;элементы с&nbsp;нечетными значениями и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка (если в&nbsp;результате удаления элементов список окажется пустым, то&nbsp;вывести&nbsp;nil). После удаления элементов из&nbsp;списка освобождать память, которую они занимали.</p>
<p class="tsk"><font face="Arial">Pointer44</font>. Дан указатель&nbsp;<i>P</i><sub>0</sub> на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Переместить данный элемент в&nbsp;конец списка и&nbsp;вывести указатели на&nbsp;первый и&nbsp;последний элементы преобразованного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer45</font>. Дан указатель&nbsp;<i>P</i><sub>0</sub> на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Переместить данный элемент в&nbsp;начало списка и&nbsp;вывести указатели на&nbsp;первый и&nbsp;последний элементы преобразованного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer46</font>. Дано число&nbsp;<i>K</i> (&gt;&nbsp;0) и&nbsp;указатель&nbsp;<i>P</i><sub>0</sub> на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Переместить в&nbsp;списке данный элемент на&nbsp;<i>K</i>&nbsp;позиций вперед (если после данного элемента находится менее&nbsp;<i>K</i>&nbsp;элементов, то&nbsp;переместить его&nbsp;в&nbsp;конец списка). Вывести указатели на&nbsp;первый и&nbsp;последний элементы преобразованного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer47</font>. Дано число&nbsp;<i>K</i> (&gt;&nbsp;0) и&nbsp;указатель&nbsp;<i>P</i><sub>0</sub> на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Переместить в&nbsp;списке данный элемент на&nbsp;<i>K</i>&nbsp;позиций назад (если перед данным элементом находится менее&nbsp;<i>K</i>&nbsp;элементов, то&nbsp;переместить его&nbsp;в&nbsp;начало списка). Вывести указатели на&nbsp;первый и&nbsp;последний элементы преобразованного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer48</font>. Даны указатели&nbsp;<i>P</i><sub><i>X</i></sub> и&nbsp;<i>P</i><sub><i>Y</i></sub> на&nbsp;два различных элемента двусвязного списка (элемент с&nbsp;адресом&nbsp;<i>P</i><sub><i>X</i></sub> находится в&nbsp;списке перед элементом с&nbsp;адресом&nbsp;<i>P</i><sub><i>Y</i></sub>, но&nbsp;не&nbsp;обязательно рядом с&nbsp;ним). Поменять местами данные элементы и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer49*</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;первый элемент непустого двусвязного списка. Перегруппировать его&nbsp;элементы, переместив все&nbsp;элементы с&nbsp;нечетными номерами в&nbsp;конец списка (в&nbsp;том&nbsp;же порядке) и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer50</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;первый элемент непустого двусвязного списка. Перегруппировать его&nbsp;элементы, переместив все&nbsp;элементы с&nbsp;нечетными значениями в&nbsp;конец списка (в&nbsp;том&nbsp;же порядке) и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer51</font>. Даны два непустых двусвязных списка и&nbsp;связанные с&nbsp;ними указатели:&nbsp;<i>P</i><sub><i>A</i></sub> и&nbsp;<i>P</i><sub><i>B</i></sub> указывают на&nbsp;первый и&nbsp;последний элементы первого списка, <i>P</i><sub><i>C</i></sub>&nbsp;&#151; на&nbsp;один из&nbsp;элементов второго. Объединить исходные списки, поместив все&nbsp;элементы первого списка (в&nbsp;том&nbsp;же порядке) перед данным элементом второго списка, и&nbsp;вывести указатели на&nbsp;первый и&nbsp;последний элементы объединенного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer52</font>. Даны два непустых двусвязных списка и&nbsp;связанные с&nbsp;ними указатели:&nbsp;<i>P</i><sub><i>A</i></sub> и&nbsp;<i>P</i><sub><i>B</i></sub> указывают на&nbsp;первый и&nbsp;последний элементы первого списка, <i>P</i><sub><i>C</i></sub>&nbsp;&#151; на&nbsp;один из&nbsp;элементов второго. Объединить исходные списки, поместив все&nbsp;элементы первого списка (в&nbsp;том&nbsp;же порядке) после данного элемента второго списка, и&nbsp;вывести указатели на&nbsp;первый и&nbsp;последний элементы объединенного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer53</font>. Даны указатели&nbsp;<i>P</i><sub><i>X</i></sub> и&nbsp;<i>P</i><sub><i>Y</i></sub> на&nbsp;два различных элемента двусвязного списка; элемент с&nbsp;адресом&nbsp;<i>P</i><sub><i>X</i></sub> находится в&nbsp;списке перед элементом с&nbsp;адресом&nbsp;<i>P</i><sub><i>Y</i></sub>, но&nbsp;не&nbsp;обязательно рядом с&nbsp;ним. Переместить элементы, расположенные между данными элементами (включая данные элементы) в&nbsp;новый список (в&nbsp;том&nbsp;же порядке). Вывести указатели на&nbsp;первые элементы преобразованного и&nbsp;нового списков. Если преобразованный список окажется пустым, то&nbsp;связанный с&nbsp;ним указатель положить равным&nbsp;nil. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer54</font>. Даны указатели&nbsp;<i>P</i><sub><i>X</i></sub> и&nbsp;<i>P</i><sub><i>Y</i></sub> на&nbsp;два различных элемента двусвязного списка; элемент с&nbsp;адресом&nbsp;<i>P</i><sub><i>X</i></sub> находится в&nbsp;списке перед элементом с&nbsp;адресом&nbsp;<i>P</i><sub><i>Y</i></sub>, но&nbsp;не&nbsp;обязательно рядом с&nbsp;ним. Переместить элементы, расположенные между данными элементами (не включая данные элементы) в&nbsp;новый список (в&nbsp;том&nbsp;же порядке). Вывести указатели на&nbsp;первые элементы преобразованного и&nbsp;нового списков. Если новый список окажется пустым, то&nbsp;связанный с&nbsp;ним указатель положить равным&nbsp;nil. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer55*</font>. Дан указатель&nbsp;<i>P</i><sub>1</sub> на&nbsp;первый элемент непустого двусвязного списка. Преобразовать список в&nbsp;<i>циклический</i>, связав его&nbsp;последний элемент с&nbsp;помощью поля Next с&nbsp;первым, а&nbsp;первый элемент с&nbsp;помощью поля Prev&nbsp;&#151; с&nbsp;последним, и&nbsp;вывести указатель на&nbsp;элемент, который был последним элементом исходного списка.</p>
<p class="tsk"><font face="Arial">Pointer56</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;первый и&nbsp;последний элементы непустого двусвязного списка, содержащего четное количество элементов. Преобразовать список в&nbsp;два <i>циклических</i> списка (см.&nbsp;задание Pointer55), первый из&nbsp;которых содержит первую половину элементов исходного списка, а&nbsp;второй&nbsp;&#151; вторую половину. Вывести указатели&nbsp;<i>P</i><sub><i>A</i></sub> и&nbsp;<i>P</i><sub><i>B</i></sub> на&nbsp;два средних элемента исходного списка (элемент с&nbsp;адресом&nbsp;<i>P</i><sub><i>A</i></sub> должен входить в&nbsp;первый циклический список, а&nbsp;элемент с&nbsp;адресом&nbsp;<i>P</i><sub><i>B</i></sub>&nbsp;&#151; во&nbsp;второй). Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer57</font>. Дано число&nbsp;<i>K</i> (&gt;&nbsp;0) и&nbsp;указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;первый и&nbsp;последний элементы непустого двусвязного списка. Осуществить <i>циклический сдвиг</i> элементов списка на&nbsp;<i>K</i>&nbsp;позиций вперед (то&nbsp;есть в&nbsp;направлении от&nbsp;начала к&nbsp;концу списка) и&nbsp;вывести указатели на&nbsp;первый и&nbsp;последний элементы полученного списка. Для выполнения циклического сдвига преобразовать исходный список в&nbsp;циклический (см.&nbsp;задание Pointer55), после чего &#171;разорвать&#187; его в&nbsp;позиции, соответствующей данному значению&nbsp;<i>K</i>. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer58</font>. Дано число&nbsp;<i>K</i> (&gt;&nbsp;0) и&nbsp;указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;первый и&nbsp;последний элементы непустого двусвязного списка. Осуществить <i>циклический сдвиг</i> элементов списка на&nbsp;<i>K</i>&nbsp;позиций назад (то&nbsp;есть в&nbsp;направлении от&nbsp;конца к&nbsp;началу списка) и&nbsp;вывести указатели на&nbsp;первый и&nbsp;последний элементы полученного списка. Для выполнения циклического сдвига преобразовать исходный список в&nbsp;циклический (см.&nbsp;задание Pointer55), после чего &#171;разорвать&#187; его в&nbsp;позиции, соответствующей данному значению&nbsp;<i>K</i>. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer59</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub> на&nbsp;первый, последний и&nbsp;текущий элементы двусвязного списка (если&nbsp;список является пустым, то&nbsp;<i>P</i><sub>1</sub>&nbsp;=&nbsp;<i>P</i><sub>2</sub>&nbsp;=&nbsp;<i>P</i><sub>3</sub>&nbsp;=&nbsp;nil). Также дано число&nbsp;<i>N</i>&nbsp;(&gt;&nbsp;0) и&nbsp;набор из&nbsp;<i>N</i>&nbsp;чисел. Описать тип TList&nbsp;&#151; запись с&nbsp;полями First, Last и Current типа PNode (поля указывают соответственно на&nbsp;<i>первый</i>, <i>последний</i> и&nbsp;<i>текущий</i> элементы списка)&nbsp;&#151; и&nbsp;процедуру InsertLast(<i>L</i>,&nbsp;<i>D</i>), которая добавляет новый элемент со&nbsp;значением&nbsp;<i>D</i> в&nbsp;конец списка&nbsp;<i>L</i> (<i>L</i>&nbsp;&#151; входной и&nbsp;выходной параметр типа TList, <i>D</i>&nbsp;&#151; входной параметр целого типа). Добавленный элемент становится текущим. С&nbsp;помощью этой&nbsp;процедуры добавить в&nbsp;конец исходного списка данный набор чисел (в&nbsp;том&nbsp;же порядке) и&nbsp;вывести новые адреса его&nbsp;первого, последнего и&nbsp;текущего элементов.</p>
<p class="tsk"><font face="Arial">Pointer60</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub> на&nbsp;первый, последний и&nbsp;текущий элементы двусвязного списка (если&nbsp;список является пустым, то&nbsp;<i>P</i><sub>1</sub>&nbsp;=&nbsp;<i>P</i><sub>2</sub>&nbsp;=&nbsp;<i>P</i><sub>3</sub>&nbsp;=&nbsp;nil). Также дано число&nbsp;<i>N</i>&nbsp;(&gt;&nbsp;0) и&nbsp;набор из&nbsp;<i>N</i>&nbsp;чисел. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуру InsertFirst(<i>L</i>,&nbsp;<i>D</i>), которая добавляет новый элемент со&nbsp;значением&nbsp;<i>D</i> в&nbsp;начало списка&nbsp;<i>L</i> (<i>L</i>&nbsp;&#151; входной и&nbsp;выходной параметр типа TList, <i>D</i>&nbsp;&#151; входной параметр целого типа). Добавленный элемент становится текущим. С&nbsp;помощью этой процедуры добавить в&nbsp;начало исходного списка данный набор чисел (добавленные числа будут располагаться в&nbsp;списке в&nbsp;обратном порядке) и&nbsp;вывести новые адреса его&nbsp;первого, последнего и&nbsp;текущего элементов.</p>
<p class="tsk"><font face="Arial">Pointer61</font>. Дан непустой двусвязный список, первый, последний и&nbsp;текущий элементы которого имеют адреса&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub>. Также даны пять чисел. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуру InsertBefore(<i>L</i>,&nbsp;<i>D</i>), которая вставляет новый элемент со&nbsp;значением&nbsp;<i>D</i> перед текущим элементом списка&nbsp;<i>L</i> (<i>L</i>&nbsp;&#151; входной и&nbsp;выходной параметр типа TList, <i>D</i>&nbsp;&#151; входной параметр целого типа). Вставленный элемент становится текущим. С&nbsp;помощью этой&nbsp;процедуры вставить пять данных чисел в&nbsp;исходный список и&nbsp;вывести новые адреса его&nbsp;первого, последнего и&nbsp;текущего элементов.</p>
<p class="tsk"><font face="Arial">Pointer62</font>. Дан непустой двусвязный список, первый, последний и&nbsp;текущий элементы которого имеют адреса&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub>. Также даны пять чисел. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуру InsertAfter(<i>L</i>,&nbsp;<i>D</i>), которая вставляет новый элемент со&nbsp;значением&nbsp;<i>D</i> после текущего элемента списка&nbsp;<i>L</i> (<i>L</i>&nbsp;&#151; входной и&nbsp;выходной параметр типа TList, <i>D</i>&nbsp;&#151; входной параметр целого типа). Вставленный элемент становится текущим. С&nbsp;помощью этой&nbsp;процедуры вставить пять данных чисел в&nbsp;исходный список и&nbsp;вывести новые адреса его&nbsp;первого, последнего и&nbsp;текущего элементов.</p>
<p class="tsk"><font face="Arial">Pointer63</font>. Дан непустой двусвязный список, первый, последний и&nbsp;текущий элементы которого имеют адреса&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub>. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуры ToFirst(<i>L</i>) (делает текущим первый элемент списка&nbsp;<i>L</i>), ToNext(<i>L</i>) (делает текущим в&nbsp;списке&nbsp;<i>L</i> следующий элемент, если&nbsp;он&nbsp;существует), SetData(<i>L</i>,&nbsp;<i>D</i>) (присваивает текущему элементу списка&nbsp;<i>L</i> значение&nbsp;<i>D</i> целого типа) и&nbsp;функцию IsLast(<i>L</i>) логического типа (возвращает True, если&nbsp;текущий элемент списка&nbsp;<i>L</i> является его&nbsp;последним элементом, и&nbsp;False в&nbsp;противном случае). Параметр&nbsp;<i>L</i> имеет тип TList; в&nbsp;процедурах ToFirst и&nbsp;ToNext он является входным и&nbsp;выходным. С&nbsp;помощью этих процедур и функций присвоить нулевые значения элементам исходного списка с&nbsp;нечетными номерами и&nbsp;вывести количество элементов в&nbsp;списке, а&nbsp;также новый адрес текущего элемента списка.</p>
<p class="tsk"><font face="Arial">Pointer64</font>. Дан непустой двусвязный список, первый, последний и&nbsp;текущий элементы которого имеют адреса&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub>. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуры ToLast(<i>L</i>) (делает текущим последний элемент списка&nbsp;<i>L</i>), ToPrev(<i>L</i>) (делает текущим в&nbsp;списке&nbsp;<i>L</i> предыдущий элемент, если он&nbsp;существует) и&nbsp;функции GetData(<i>L</i>) целого типа (возвращает значение текущего элемента списка&nbsp;<i>L</i>), IsFirst(<i>L</i>) логического типа (возвращает True, если текущий элемент списка&nbsp;<i>L</i> является его&nbsp;первым элементом, и&nbsp;False в&nbsp;противном случае). Параметр&nbsp;<i>L</i> имеет тип TList; в&nbsp;процедурах ToLast и&nbsp;ToPrev он является входным и&nbsp;выходным. С&nbsp;помощью этих процедур и функций вывести все&nbsp;четные значения элементов исходного списка, просматривая список с&nbsp;конца. Вывести также количество элементов в&nbsp;списке.</p>
<p class="tsk"><font face="Arial">Pointer65</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub> на&nbsp;первый, последний и&nbsp;текущий элементы двусвязного списка, содержащего не&nbsp;менее пяти&nbsp;элементов. Используя тип TList (см.&nbsp;задание Pointer59), описать функцию DeleteCurrent(<i>L</i>) целого типа, удаляющую из&nbsp;списка&nbsp;<i>L</i> текущий элемент и&nbsp;возвращающую его&nbsp;значение (<i>L</i>&nbsp;&#151; входной и&nbsp;выходной параметр типа TList). После удаления элемента текущим становится следующий элемент или, если&nbsp;следующего элемента не&nbsp;существует, последний элемент списка. Функция также освобождает память, занимаемую удаленным элементом. С&nbsp;помощью этой&nbsp;функции удалить из&nbsp;исходного списка пять&nbsp;элементов и&nbsp;вывести их&nbsp;значения. Вывести также новые адреса первого, последнего и&nbsp;текущего элементов списка.</p>
<p class="tsk"><font face="Arial">Pointer66</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub> на&nbsp;первый, последний и&nbsp;текущий элементы непустого двусвязного списка. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуру SplitList(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>), которая переносит элементы списка&nbsp;<i>L</i><sub>1</sub> от&nbsp;текущего до&nbsp;последнего в&nbsp;новый список&nbsp;<i>L</i><sub>2</sub> (таким образом, список&nbsp;<i>L</i><sub>1</sub> делится на&nbsp;две части, причем первая часть может оказаться пустой). Параметры процедуры имеют тип TList; первый параметр является входным и&nbsp;выходным, второй&nbsp;&#151; выходным. Текущими элементами непустых результирующих списков становятся их&nbsp;первые элементы. Операции выделения и&nbsp;освобождения памяти в&nbsp;процедуре не&nbsp;использовать. С&nbsp;помощью этой&nbsp;процедуры разбить исходный список на&nbsp;два и&nbsp;вывести адреса первого, последнего и&nbsp;текущего элементов полученных списков.</p>
<p class="tsk"><font face="Arial">Pointer67</font>. Даны указатели на&nbsp;первый, последний и&nbsp;текущий элементы двух&nbsp;непустых двусвязных списков. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуру AddList(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>), которая добавляет все&nbsp;элементы из&nbsp;списка&nbsp;<i>L</i><sub>2</sub> (в&nbsp;том&nbsp;же порядке) в&nbsp;конец списка&nbsp;<i>L</i><sub>1</sub>; в&nbsp;результате список&nbsp;<i>L</i><sub>2</sub> становится пустым. Текущим элементом списка&nbsp;<i>L</i><sub>1</sub> становится первый из&nbsp;добавленных элементов. Оба параметра процедуры имеют тип TList и&nbsp;являются входными и&nbsp;выходными. Операции выделения и&nbsp;освобождения памяти в&nbsp;процедуре не&nbsp;использовать. С&nbsp;помощью этой&nbsp;процедуры добавить второй из&nbsp;исходных списков в&nbsp;конец первого и&nbsp;вывести адреса первого, последнего и&nbsp;текущего элементов объединенного списка.</p>
<p class="tsk"><font face="Arial">Pointer68</font>. Даны указатели на&nbsp;первый, последний и&nbsp;текущий элементы двух&nbsp;непустых двусвязных списков. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуру InsertList(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>), которая вставляет все&nbsp;элементы из&nbsp;списка&nbsp;<i>L</i><sub>2</sub> (в&nbsp;том&nbsp;же порядке) в&nbsp;список&nbsp;<i>L</i><sub>1</sub> перед его&nbsp;текущим элементом; в&nbsp;результате список&nbsp;<i>L</i><sub>2</sub> становится пустым. Текущим элементом списка&nbsp;<i>L</i><sub>1</sub> становится первый из&nbsp;вставленных элементов. Оба параметра процедуры имеют тип TList и&nbsp;являются входными и&nbsp;выходными. Операции выделения и&nbsp;освобождения памяти в&nbsp;процедуре не&nbsp;использовать. С&nbsp;помощью этой&nbsp;процедуры вставить второй из&nbsp;исходных списков в&nbsp;текущую позицию первого и&nbsp;вывести адреса первого, последнего и&nbsp;текущего элементов объединенного списка.</p>
<p class="tsk"><font face="Arial">Pointer69</font>. Даны указатели на&nbsp;первый, последний и&nbsp;текущий элементы двух&nbsp;двусвязных списков (второй список может быть пустым). Используя тип TList (см.&nbsp;задание Pointer59), описать процедуру MoveCurrent(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>), которая перемещает текущий элемент списка&nbsp;<i>L</i><sub>1</sub> в&nbsp;список&nbsp;<i>L</i><sub>2</sub> (элемент вставляется после текущего элемента списка&nbsp;<i>L</i><sub>2</sub> и&nbsp;сам становится текущим; в&nbsp;списке&nbsp;<i>L</i><sub>1</sub> текущим становится следующий элемент или, если&nbsp;следующего элемента не&nbsp;существует, последний элемент). Оба параметра процедуры имеют тип TList и&nbsp;являются входными и&nbsp;выходными. Операции выделения и&nbsp;освобождения памяти в&nbsp;процедуре не&nbsp;использовать. С&nbsp;помощью этой&nbsp;процедуры переместить текущий элемент первого списка во&nbsp;второй и&nbsp;вывести адреса первого, последнего и&nbsp;текущего элементов полученных списков.</p>
<p class="cmt">Использованная в&nbsp;заданиях Pointer31&#150;Pointer69 реализация двусвязного списка в&nbsp;виде цепочки узлов, ограниченной по&nbsp;краям нулевыми указателями, не&nbsp;является единственно возможной. Двусвязный список можно также реализовать в&nbsp;виде <i>замкнутой</i> цепочки узлов с&nbsp;дополнительным <i>фиктивным</i>, или&nbsp;<i>барьерным</i>, элементом. Этот&nbsp;барьерный элемент связан своими полями Next и&nbsp;Prev с&nbsp;первым и&nbsp;последним &#171;настоящим&#187; элементом списка соответственно, поэтому, имея указатель на&nbsp;барьерный элемент, можно сразу перейти как к&nbsp;первому, так и&nbsp;к&nbsp;последнему элементу списка (естественно, первый и&nbsp;последний элементы также связаны с&nbsp;барьерным элементом своими полями Prev и Next соответственно). Для&nbsp;работы с&nbsp;двусвязным списком, снабженным барьерным элементом, достаточно хранить два&nbsp;указателя: Barrier, указывающий на&nbsp;барьерный элемент, и&nbsp;Current, указывающий на&nbsp;текущий элемент (который может быть как&nbsp;&#171;настоящим&#187;, так и&nbsp;барьерным элементом). Поле Data барьерного элемента может быть произвольным; для&nbsp;определенности его обычно полагают равным&nbsp;0. <i>Пустой список</i> в&nbsp;данной реализации представляет собой единственный барьерный элемент, &#171;замкнутый на&nbsp;себя&#187;.</p>
<p class="cmt">Задания Pointer70&#150;Pointer80 посвящены <i>двусвязным спискам с&nbsp;барьерным элементом</i>.</p>
<p class="tsk"><font face="Arial">Pointer70</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;первый и&nbsp;последний элементы двусвязного списка, реализованного в&nbsp;виде цепочки узлов, ограниченной по&nbsp;краям нулевыми указателями (если&nbsp;список пуст, то&nbsp;<i>P</i><sub>1</sub>&nbsp;=&nbsp;<i>P</i><sub>2</sub>&nbsp;=&nbsp;nil). Преобразовать исходный список в&nbsp;<i>циклический список</i> (см.&nbsp;задание Pointer55), снабженный <i>барьерным элементом</i>. Барьерный элемент должен иметь значение&nbsp;0 и&nbsp;быть связан своими полями Next и&nbsp;Prev с&nbsp;первым и&nbsp;последним элементом исходного списка (в&nbsp;случае пустого исходного списка поля Next и&nbsp;Prev барьерного элемента должны указывать на&nbsp;сам&nbsp;барьерный элемент). Вывести указатель на&nbsp;барьерный элемент полученного списка. Операцию выделения памяти использовать только для&nbsp;создания барьерного элемента.</p>
<p class="tsk"><font face="Arial">Pointer71</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;барьерный и&nbsp;текущий элементы двусвязного списка (о&nbsp;списке с&nbsp;<i>барьерным элементом</i> см.&nbsp;задание Pointer70). Разбить список на&nbsp;два, перенеся во&nbsp;второй список все&nbsp;элементы от&nbsp;текущего до&nbsp;последнего и&nbsp;добавив ко&nbsp;второму списку барьерный элемент. Если&nbsp;текущий элемент исходного списка является барьерным элементом, то&nbsp;второй список должен быть пустым (то&nbsp;есть состоять только из&nbsp;барьерного элемента). Вывести указатель на&nbsp;барьерный элемент второго списка. Операцию выделения памяти использовать только для&nbsp;создания барьерного элемента второго списка.</p>
<p class="tsk"><font face="Arial">Pointer72</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;барьерные элементы двух двусвязных списков (о&nbsp;списке с&nbsp;<i>барьерным элементом</i> см.&nbsp;задание Pointer70). Объединить исходные списки, связав конец первого и&nbsp;начало второго списка (барьерным элементом объединенного списка должен остаться барьерный элемент первого списка). Вывести указатели на&nbsp;первый и&nbsp;последний элементы объединенного списка (если&nbsp;объединенный список является пустым, то&nbsp;дважды вывести указатель на&nbsp;его&nbsp;барьерный элемент). После удаления лишнего барьерного элемента освободить занимаемую им&nbsp;память.</p>
<p class="tsk"><font face="Arial">Pointer73</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;барьерные элементы двух двусвязных списков (о&nbsp;списке с&nbsp;<i>барьерным элементом</i> см.&nbsp;задание Pointer70). Объединить исходные списки, связав конец первого и&nbsp;начало второго списка (барьерным элементом объединенного списка должен остаться барьерный элемент второго списка). Вывести указатели на&nbsp;первый и&nbsp;последний элементы объединенного списка (если&nbsp;объединенный список является пустым, то&nbsp;дважды вывести указатель на&nbsp;его&nbsp;барьерный элемент). После удаления лишнего барьерного элемента освободить занимаемую им&nbsp;память.</p>
<p class="tsk"><font face="Arial">Pointer74</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;барьерный и&nbsp;текущий элементы двусвязного списка (о&nbsp;списке с&nbsp;<i>барьерным элементом</i> см.&nbsp;задание Pointer70). Также дано число&nbsp;<i>N</i>&nbsp;(&gt;&nbsp;0) и&nbsp;набор из&nbsp;<i>N</i>&nbsp;чисел. Описать тип TListB&nbsp;&#151; запись с&nbsp;полями Barrier и&nbsp;Current типа PNode (поля указывают соответственно на&nbsp;барьерный и&nbsp;текущий элементы списка)&nbsp;&#151; и&nbsp;процедуру LBInsertLast(<i>L</i>,&nbsp;<i>D</i>), которая добавляет новый элемент со&nbsp;значением&nbsp;<i>D</i> в&nbsp;конец списка&nbsp;<i>L</i> (<i>L</i>&nbsp;&#151; входной и&nbsp;выходной параметр типа TListB, <i>D</i>&nbsp;&#151; входной параметр целого типа). Добавленный элемент становится текущим. С&nbsp;помощью этой&nbsp;процедуры добавить в&nbsp;конец исходного списка данный набор чисел (в&nbsp;том&nbsp;же порядке) и&nbsp;вывести адрес текущего элемента полученного списка.</p>
<p class="tsk"><font face="Arial">Pointer75</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;барьерный и&nbsp;текущий элементы двусвязного списка. Также дано число&nbsp;<i>N</i>&nbsp;(&gt;&nbsp;0) и&nbsp;набор из&nbsp;<i>N</i>&nbsp;чисел. Используя тип TListB (см.&nbsp;задание Pointer74), описать процедуру LBInsertFirst(<i>L</i>,&nbsp;<i>D</i>), которая добавляет новый элемент со&nbsp;значением&nbsp;<i>D</i> в&nbsp;начало списка&nbsp;<i>L</i> (<i>L</i>&nbsp;&#151; входной и&nbsp;выходной параметр типа TListB, <i>D</i>&nbsp;&#151; входной параметр целого типа). Добавленный элемент становится текущим. С&nbsp;помощью этой&nbsp;процедуры добавить в&nbsp;начало исходного списка данный набор чисел (добавленные числа будут располагаться в&nbsp;списке в&nbsp;обратном порядке) и&nbsp;вывести адрес текущего элемента полученного списка.</p>
<p class="tsk"><font face="Arial">Pointer76</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;барьерный и&nbsp;текущий элементы двусвязного списка. Также даны пять чисел. Используя тип TListB (см.&nbsp;задание Pointer74), описать процедуру LBInsertBefore(<i>L</i>,&nbsp;<i>D</i>), которая вставляет новый элемент со&nbsp;значением&nbsp;<i>D</i> перед текущим элементом списка&nbsp;<i>L</i> (<i>L</i>&nbsp;&#151; входной и&nbsp;выходной параметр типа TListB, <i>D</i>&nbsp;&#151; входной параметр целого типа). Вставленный элемент становится текущим. С&nbsp;помощью этой&nbsp;процедуры вставить пять данных чисел в&nbsp;исходный список и&nbsp;вывести новый адрес его&nbsp;текущего элемента.</p>
<p class="tsk"><font face="Arial">Pointer77</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;барьерный и&nbsp;текущий элементы двусвязного списка. Также даны пять чисел. Используя тип TListB (см.&nbsp;задание Pointer74), описать процедуру LBInsertAfter(<i>L</i>,&nbsp;<i>D</i>), которая вставляет новый элемент со&nbsp;значением&nbsp;<i>D</i> после текущего элемента списка&nbsp;<i>L</i> (<i>L</i>&nbsp;&#151; входной и&nbsp;выходной параметр типа TListB, <i>D</i>&nbsp;&#151; входной параметр целого типа). Вставленный элемент становится текущим. С&nbsp;помощью этой&nbsp;процедуры вставить пять данных чисел в&nbsp;исходный список и&nbsp;вывести новый адрес его&nbsp;текущего элемента.</p>
<p class="tsk"><font face="Arial">Pointer78</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;барьерный и&nbsp;текущий элементы двусвязного списка. Используя тип TListB (см.&nbsp;задание Pointer74), описать процедуры LBToFirst(<i>L</i>) (делает текущим первый элемент списка&nbsp;<i>L</i>), LBToNext(<i>L</i>) (делает текущим в&nbsp;списке&nbsp;<i>L</i> следующий элемент), LBSetData(<i>L</i>,&nbsp;<i>D</i>) (присваивает текущему элементу списка&nbsp;<i>L</i> значение&nbsp;<i>D</i> целого типа, если&nbsp;данный элемент не&nbsp;является барьерным) и&nbsp;функцию IsBarrier(<i>L</i>) логического типа (возвращает True, если текущий элемент списка&nbsp;<i>L</i> является его&nbsp;барьерным элементом, и&nbsp;False в&nbsp;противном случае). Параметр&nbsp;<i>L</i> имеет тип TListB; в&nbsp;процедурах LBToFirst и&nbsp;LBToNext он является входным и&nbsp;выходным. С&nbsp;помощью этих процедур и функций присвоить нулевые значения элементам исходного списка с&nbsp;нечетными номерами и&nbsp;вывести количество элементов в&nbsp;списке, а&nbsp;также новый адрес текущего элемента списка. Барьерный элемент при&nbsp;подсчете элементов не&nbsp;учитывать.</p>
<p class="tsk"><font face="Arial">Pointer79</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;барьерный и&nbsp;текущий элементы двусвязного списка. Используя тип TListB (см.&nbsp;задание Pointer74), описать процедуры LBToLast(<i>L</i>) (делает текущим последний элемент списка&nbsp;<i>L</i>), LBToPrev(<i>L</i>) (делает текущим в&nbsp;списке&nbsp;<i>L</i> предыдущий элемент) и&nbsp;функцию LBGetData(<i>L</i>) целого типа (возвращает значение текущего элемента списка&nbsp;<i>L</i>). Параметр&nbsp;<i>L</i> имеет тип TListB; в&nbsp;процедурах LBToLast и&nbsp;LBToPrev он является входным и&nbsp;выходным. С&nbsp;помощью этих процедур и функций, а&nbsp;также с&nbsp;использованием функции IsBarrier из&nbsp;задания Pointer78, вывести все&nbsp;четные значения элементов исходного списка, просматривая список с&nbsp;конца. Вывести также количество элементов в&nbsp;списке. Барьерный элемент при&nbsp;подсчете элементов не&nbsp;учитывать.</p>
<p class="tsk"><font face="Arial">Pointer80</font>. Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на&nbsp;барьерный и&nbsp;текущий элементы непустого двусвязного списка, причем текущий элемент не&nbsp;совпадает с барьерным. Используя тип TListB (см.&nbsp;задание Pointer74), описать функцию LBDeleteCurrent(<i>L</i>) целого типа, удаляющую из&nbsp;списка&nbsp;<i>L</i> текущий элемент и&nbsp;возвращающую его&nbsp;значение (<i>L</i>&nbsp;&#151; входной и выходной параметр типа TListB). Текущим становится следующий элемент или, если&nbsp;следующий элемент является барьерным, предыдущий элемент списка. Функция также освобождает память, занимаемую удаленным элементом. Если текущим элементом является барьерный элемент, то&nbsp;функция не&nbsp;выполняет никаких действий и&nbsp;возвращает&nbsp;0. С&nbsp;помощью этой&nbsp;функции, а&nbsp;также функции IsBarrier из&nbsp;задания Pointer78, удалить из&nbsp;исходного списка пять&nbsp;элементов (или&nbsp;все элементы, если их&nbsp;менее пяти) и&nbsp;вывести их&nbsp;значения. Вывести также новый адрес текущего элемента списка.</p>
<hr noshade><div align=right><font size=-1>Дата генерации страницы: 22.03.2005.</font></div></body></html>
