<!-- Programming Taskbook 4.4 | Copyright (c) M. Abramyan, 1998-2005 -->
<html><head><meta http-equiv="pragma" content="no-cache"><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>Programming Taskbook 4.4 | Указатели и динамические структуры данных</title>
</head><body vlink="#003366" link="#003366"><style>
H1{font-family:"Arial";font-size:20pt;text-indent:0;margin-top:10; margin-right:10; margin-bottom:0; margin-left:10;}
H2{font-family:"Arial";font-size:16pt;text-indent:0;margin: 20 10 0 10;}
H3{font-family:"Arial";font-size:12pt;text-indent:0;margin: 20 10 0 10;}
P{font-family:"Times New Roman";font-size:12pt;text-indent:0;margin-top:0; margin-right:10; margin-bottom:0; margin-left:10;}
center{font-family:"Times New Roman";font-size:12pt;}
TABLE{margin-top:0; margin-bottom:0;}
TD{font-family:"Times New Roman";font-size:12pt;}
LI{font-family:"Times New Roman";font-size:12pt;}
UL{font-family:"Times New Roman";font-size:12pt;}
P.tsk{text-align:left;text-indent:-50;margin-top:5; margin-left:60;}
P.hnt{text-align:left;margin-left:60;}
P.hntc{text-align:left;margin-left:60;}
P.hntq{text-align:left;margin-left: 60;}
P.cmt{text-align:left;margin-top:5;}
P.ttt{text-align:left;}
P.cnt{text-align:center;}
P.qte{text-align:left;margin-left:120;margin-top:0;margin-bottom:0;}
blockquote{font-family:"Times New Roman";text-align:left;margin-left:100;margin-top:0; margin-bottom:0;}
P.cmtc{text-align:left;}
P.cmtq{text-align:left;}
SUB{font-family:"Times New Roman";font-size:8pt;}
SUP{font-family:"Times New Roman";font-size:8pt;}
P.foot{text-align:right;font-size:8pt;margin-right:0;}
</style>
<script language="javascript" src="back.js">
</script>
<font face="Arial" size=+3><b>Programming Taskbook 4</b><br></font>
<font face="Arial" size=+1>Электронный задачник по программированию</font>
<div align=right><font size = -1>&copy;&nbsp;&nbsp;М.&nbsp;Э.&nbsp;Абрамян,&nbsp;1998&#150;2005</font></div>
<hr noshade>
<div align=center><font size=-1>
[<a href="indexd.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/indexd.htm">Общее&nbsp;описание</a>] [<a href="remarksd.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/remarksd.htm">Предварительные&nbsp;замечания</a>] [<a href="begind.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/begind.htm">Ввод&nbsp;и&nbsp;вывод&nbsp;данных,&nbsp;оператор&nbsp;присваивания</a>] [<a href="integerd.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/integerd.htm">Целые&nbsp;числа</a>] [<a href="booleand.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/booleand.htm">Логические&nbsp;выражения</a>] [<a href="ifd.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/ifd.htm">Условный&nbsp;оператор</a>] [<a href="cased.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/cased.htm">Оператор&nbsp;выбора</a>] [<a href="ford.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/ford.htm">Цикл&nbsp;с&nbsp;параметром</a>] [<a href="whiled.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/whiled.htm">Цикл&nbsp;с&nbsp;условием</a>] [<a href="seriesd.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/seriesd.htm">Последовательности</a>] [<a href="procd.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/procd.htm">Процедуры&nbsp;и&nbsp;функции</a>] [<a href="minmaxd.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/minmaxd.htm">Минимумы&nbsp;и&nbsp;максимумы</a>] [<a href="arrayd.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/arrayd.htm">Одномерные&nbsp;массивы</a>] [<a href="matrixd.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/matrixd.htm">Двумерные&nbsp;массивы&nbsp;(матрицы)</a>] [<a href="stringd.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/stringd.htm">Символы&nbsp;и&nbsp;строки</a>] [<a href="filed.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/filed.htm">Двоичные&nbsp;(типизированные)&nbsp;файлы</a>] [<a href="textd.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/textd.htm">Текстовые&nbsp;файлы</a>] [<a href="paramd.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/paramd.htm">Составные&nbsp;типы&nbsp;данных&nbsp;в&nbsp;процедурах&nbsp;и&nbsp;функциях</a>] [<a href="recurd.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/recurd.htm">Рекурсия</a>] [<b>Указатели&nbsp;и&nbsp;динамические&nbsp;структуры&nbsp;данных</b>] [<a href="demod.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/demod.htm">Задания&nbsp;демо-версии</a>]
</font></div><hr noshade><div align=right><font size=-1>Стиль: [<b>DOS-программа</b>] [<a href="pointerw.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/pointerw.htm">Windows-программа</a>] [<a href="pointer.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/pointer.htm">Книга</a>]</font></div>

<p class="cmt"><h1>Указатели и динамические структуры данных</h1></p>
<p class="cmt">Данная группа не&nbsp;включена в&nbsp;варианты задачника для языков Visual Basic и&nbsp;C#.</p>
<p class="cmt">Все&nbsp;числа, упоминаемые в&nbsp;заданиях данной группы, являются целыми. Все&nbsp;указатели имеют тип PNode и&nbsp;указывают на&nbsp;записи типа TNode. Типы PNode и&nbsp;TNode описаны в&nbsp;варианте задачника для&nbsp;языка Pascal следующим образом: </p><p class="qte">type<br> &nbsp; &nbsp;PNode = ^TNode;<br> &nbsp; &nbsp;TNode = record<br> &nbsp; &nbsp; &nbsp; &nbsp;Data: integer;<br> &nbsp; &nbsp; &nbsp; &nbsp;Next: PNode;<br> &nbsp; &nbsp; &nbsp; &nbsp;Prev: PNode;<br> &nbsp; &nbsp;end;</p>
<p class="cmt">Аналогично описываются эти типы в&nbsp;варианте задачника для&nbsp;языка&nbsp;С: </p><p class="qte">struct TNode<br>{<br> &nbsp; &nbsp;int Data;<br> &nbsp; &nbsp;TNode* Next;<br> &nbsp; &nbsp;TNode* Prev;<br>};<br><br>typedef TNode* PNode;</p>
<p class="cmt">В&nbsp;заданиях на&nbsp;стеки и&nbsp;очереди (Pointer1&#150;Pointer28) при&nbsp;работе с&nbsp;записями типа TNode используются только поля Data и&nbsp;Next (см.&nbsp;задание Pointer1); в&nbsp;заданиях на двусвязные спискиа (Pointer29&#150;Pointer80) используются все&nbsp;поля записи TNode (см.&nbsp;задание Pointer29).</p>
<p class="cmt">Так как переменные типа "указатель" предназначены для&nbsp;хранения адресов, в&nbsp;формулировках заданий слова "указатель" (на&nbsp;элемент данных) и "адрес" (элемента данных) используются как&nbsp;синонимы.</p>
<p class="cmt">Для&nbsp;обозначения нулевого указателя в&nbsp;формулировках заданий используется имя&nbsp;nil.</p>
<p class="cmt"><h2>Стеки</h2></p>
<p class="tsk"><font face="Arial">Pointer1</font>. Дан адрес&nbsp;P1 записи типа TNode, содержащей поле Data (целого типа) и&nbsp;поле Next (типа PNode&nbsp;&#151; указателя на&nbsp;TNode). Эта&nbsp;запись связана полем Next со&nbsp;следующей записью того&nbsp;же типа. Вывести значения полей Data обеих записей, а&nbsp;также адрес&nbsp;P2 следующей записи.</p>
<p class="tsk"><font face="Arial">Pointer2*</font>. Дан адрес&nbsp;P1 записи типа TNode. Эта&nbsp;запись связана полем Next со&nbsp;следующей записью того&nbsp;же типа, она, в&nbsp;свою очередь,&nbsp;&#151; со&nbsp;следующей, и&nbsp;так&nbsp;далее до&nbsp;записи, поле Next которой равно&nbsp;nil (таким образом, возникает цепочка связанных записей). Вывести значения полей Data для&nbsp;всех элементов цепочки, длину цепочки (то&nbsp;есть число ее&nbsp;элементов) и&nbsp;адрес ее&nbsp;последнего элемента.</p>
<p class="cmt">В заданиях Pointer3&#150;Pointer13 структура "стек" (stack) моделируется цепочкой связанных узлов-записей типа TNode (см.&nbsp;задание Pointer2). Поле Next последнего элемента цепочки равно&nbsp;nil. Вершиной стека (top) считается первый элемент цепочки. Для&nbsp;доступа к&nbsp;стеку используется указатель на&nbsp;его&nbsp;вершину (для&nbsp;пустого стека данный указатель полагается равным&nbsp;nil). Значением элемента стека считается значение его&nbsp;поля&nbsp;Data.</p>
<p class="tsk"><font face="Arial">Pointer3*</font>. Дано число&nbsp;D и&nbsp;указатель&nbsp;P1 на&nbsp;вершину непустого стека. Добавить элемент со&nbsp;значением&nbsp;D в&nbsp;стек и&nbsp;вывести адрес&nbsp;P2 новой вершины стека.</p>
<p class="tsk"><font face="Arial">Pointer4</font>. Дано число&nbsp;N (&gt;&nbsp;0) и&nbsp;набор из&nbsp;N&nbsp;чисел. Создать стек, содержащий исходные числа (последнее число будет вершиной стека), и&nbsp;вывести указатель на&nbsp;его&nbsp;вершину.</p>
<p class="tsk"><font face="Arial">Pointer5*</font>. Дан указатель&nbsp;P1 на вершину непустого стека. Извлечь из&nbsp;стека первый (верхний) элемент и&nbsp;вывести его&nbsp;значение&nbsp;D, а&nbsp;также адрес&nbsp;P2 новой вершины стека. Если после извлечения элемента стек окажется пустым, то&nbsp;положить P2&nbsp;=&nbsp;nil. После извлечения элемента из&nbsp;стека освободить память, занимаемую этим элементом.</p>
<p class="tsk"><font face="Arial">Pointer6</font>. Дан указатель&nbsp;P1 на&nbsp;вершину стека, содержащего не&nbsp;менее десяти элементов. Извлечь из&nbsp;стека первые девять элементов и&nbsp;вывести их&nbsp;значения. Вывести также адрес новой вершины стека. После извлечения элементов из&nbsp;стека освобождать память, которую они занимали.</p>
<p class="tsk"><font face="Arial">Pointer7</font>. Дан указатель&nbsp;P1 на&nbsp;вершину стека (если стек пуст, то&nbsp;P1&nbsp;=&nbsp;nil). Извлечь из&nbsp;стека все&nbsp;элементы и&nbsp;вывести их&nbsp;значения. Вывести также количество извлеченных элементов&nbsp;N (для&nbsp;пустого стека вывести&nbsp;0). После извлечения элементов из&nbsp;стека освобождать память, которую они занимали.</p>
<p class="tsk"><font face="Arial">Pointer8*</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;вершины двух непустых стеков. Переместить все&nbsp;элементы из&nbsp;первого стека во&nbsp;второй (в&nbsp;результате элементы первого стека будут располагаться во&nbsp;втором стеке в&nbsp;порядке, обратном исходному) и&nbsp;вывести адрес новой вершины второго стека. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer9</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;вершины двух непустых стеков. Перемещать элементы из&nbsp;первого стека во&nbsp;второй, пока значение вершины первого стека не&nbsp;станет четным (перемещенные элементы первого стека будут располагаться во&nbsp;втором стеке в&nbsp;порядке, обратном исходному). Если в&nbsp;первом стеке нет&nbsp;элементов с&nbsp;четными значениями, то&nbsp;переместить из&nbsp;первого стека во&nbsp;второй все&nbsp;элементы. Вывести адреса новых вершин первого и&nbsp;второго стека (если первый стек окажется пустым, то&nbsp;вывести для него константу nil). Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer10</font>. Дан указатель&nbsp;P1 на&nbsp;вершину непустого стека. Создать два&nbsp;новых стека, переместив в&nbsp;первый из&nbsp;них все&nbsp;элементы исходного стека с&nbsp;четными значениями, а&nbsp;во&nbsp;второй&nbsp;&#151; с&nbsp;нечетными (элементы в&nbsp;новых стеках будут располагаться в&nbsp;порядке, обратном исходному; один из&nbsp;этих стеков может оказаться пустым). Вывести адреса вершин полученных стеков (для&nbsp;пустого стека вывести&nbsp;nil). Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer11*</font>. Дан указатель&nbsp;P1 на&nbsp;вершину стека (если стек пуст, то&nbsp;P1&nbsp;=&nbsp;nil). Также дано число&nbsp;N (&gt;&nbsp;0) и&nbsp;набор из&nbsp;N&nbsp;чисел. Описать тип TStack&nbsp;&#151; запись с&nbsp;одним полем Top типа PNode (поле указывает на&nbsp;вершину стека)&nbsp;&#151; и&nbsp;процедуру Push(S,&nbsp;D), которая добавляет в&nbsp;стек&nbsp;S новый элемент со&nbsp;значением&nbsp;D (S&nbsp;&#151; входной и&nbsp;выходной параметр типа TStack, D&nbsp;&#151; входной параметр целого типа). С&nbsp;помощью процедуры Push добавить в&nbsp;исходный стек данный набор чисел (последнее число будет вершиной стека) и&nbsp;вывести адрес новой вершины стека.</p>
<p class="tsk"><font face="Arial">Pointer12</font>. Дан указатель&nbsp;P1 на&nbsp;вершину стека, содержащего не&nbsp;менее пяти элементов. Используя тип TStack (см.&nbsp;задание Pointer11), описать функцию Pop(S) целого типа, которая извлекает из&nbsp;стека&nbsp;S первый (верхний) элемент, возвращает его значение и&nbsp;освобождает память, которую занимал извлеченный элемент (S&nbsp;&#151; входной и&nbsp;выходной параметр типа TStack). С&nbsp;помощью функции Pop извлечь из&nbsp;исходного стека пять&nbsp;элементов и&nbsp;вывести их&nbsp;значения. Вывести также указатель на&nbsp;новую вершину стека (если результирующий стек окажется пустым, то этот указатель должен быть равен&nbsp;nil).</p>
<p class="tsk"><font face="Arial">Pointer13</font>. Дан указатель&nbsp;P1 на&nbsp;вершину стека. Используя тип TStack (см.&nbsp;задание Pointer11), описать функции StackIsEmpty(S) логического типа (возвращает True, если стек&nbsp;S пуст, и&nbsp;False в&nbsp;противном случае) и&nbsp;Peek(S) целого типа (возвращает значение вершины непустого стека&nbsp;S, не&nbsp;удаляя&nbsp;ее из&nbsp;стека). В&nbsp;обеих функциях переменная&nbsp;S является входным параметром типа TStack. С&nbsp;помощью этих&nbsp;функций, а&nbsp;также функции Pop из&nbsp;задания Pointer12, извлечь из&nbsp;исходного стека пять&nbsp;элементов (или&nbsp;все содержащиеся в&nbsp;нем элементы, если&nbsp;их менее пяти) и&nbsp;вывести их&nbsp;значения. Вывести также значение функции StackIsEmpty для&nbsp;результирующего стека и, если&nbsp;результирующий стек не&nbsp;является пустым, значение и&nbsp;адрес его&nbsp;новой вершины.</p>
<p class="cmt"><h2>Очереди</h2></p>
<p class="cmt">В&nbsp;заданиях Pointer14&#150;Pointer28 структура "очередь" (queue) моделируется цепочкой связанных узлов-записей типа TNode (см.&nbsp;задание Pointer2). Поле Next последнего элемента цепочки равно&nbsp;nil. Началом очереди ("головой", head)  считается первый элемент цепочки, концом ("хвостом", tail)&nbsp;&#151; ее&nbsp;последний элемент. Для&nbsp;возможности быстрого добавления в&nbsp;конец очереди нового элемента удобно хранить, помимо указателя на&nbsp;начало очереди, также и&nbsp;указатель на&nbsp;ее&nbsp;конец. В&nbsp;случае пустой очереди указатели на&nbsp;ее&nbsp;начало и&nbsp;конец полагаются равными&nbsp;nil. Как и&nbsp;для&nbsp;стека, значением элемента очереди считается значение его&nbsp;поля&nbsp;Data.</p>
<p class="tsk"><font face="Arial">Pointer14</font>. Дан набор из&nbsp;10&nbsp;чисел. Создать очередь, содержащую данные числа в&nbsp;указанном порядке (первое число будет размещаться в&nbsp;начале очереди, последнее&nbsp;&#151; в&nbsp;конце), и&nbsp;вывести указатели&nbsp;P1 и&nbsp;P2 на&nbsp;начало и&nbsp;конец очереди.</p>
<p class="tsk"><font face="Arial">Pointer15</font>. Дан набор из&nbsp;10&nbsp;чисел. Создать две&nbsp;очереди: первая должна содержать числа из&nbsp;исходного набора с&nbsp;нечетными номерами (1, 3,&nbsp;&#133;,&nbsp;9), а&nbsp;вторая&nbsp;&#151; с&nbsp;четными (2, 4,&nbsp;&#133;,&nbsp;10); порядок чисел в&nbsp;каждой очереди должен совпадать с&nbsp;порядком чисел в&nbsp;исходном наборе. Вывести указатели на&nbsp;начало и&nbsp;конец первой, а&nbsp;затем второй очереди.</p>
<p class="tsk"><font face="Arial">Pointer16</font>. Дан набор из 10&nbsp;чисел. Создать две&nbsp;очереди: первая должна содержать все нечетные, а&nbsp;вторая&nbsp;&#151; все четные числа из&nbsp;исходного набора (порядок чисел в&nbsp;каждой очереди должен совпадать с&nbsp;порядком чисел в&nbsp;исходном наборе). Вывести указатели на&nbsp;начало и&nbsp;конец первой, а&nbsp;затем второй очереди (одна из&nbsp;очередей может оказаться пустой; в&nbsp;этом случае вывести для&nbsp;нее две константы&nbsp;nil).</p>
<p class="tsk"><font face="Arial">Pointer17</font>. Дано число&nbsp;D и&nbsp;указатели&nbsp;P1 и&nbsp;P2 на&nbsp;начало и&nbsp;конец очереди (если очередь является пустой, то P1&nbsp;=&nbsp;P2&nbsp;=&nbsp;nil). Добавить элемент со&nbsp;значением&nbsp;D в&nbsp;конец очереди и&nbsp;вывести новые адреса начала и&nbsp;конца очереди.</p>
<p class="tsk"><font face="Arial">Pointer18</font>. Дано число&nbsp;D и&nbsp;указатели&nbsp;P1 и&nbsp;P2 на&nbsp;начало и&nbsp;конец очереди, содержащей не&nbsp;менее двух&nbsp;элементов. Добавить элемент со&nbsp;значением&nbsp;D в&nbsp;конец очереди и&nbsp;извлечь из&nbsp;очереди первый (начальный) элемент. Вывести значение извлеченного элемента и&nbsp;новые адреса начала и&nbsp;конца очереди. После извлечения элемента из&nbsp;очереди освободить память, занимаемую этим элементом.</p>
<p class="tsk"><font face="Arial">Pointer19</font>. Дано число&nbsp;N (&gt;&nbsp;0) и&nbsp;указатели&nbsp;P1 и&nbsp;P2 на&nbsp;начало и&nbsp;конец непустой очереди. Извлечь из&nbsp;очереди N&nbsp;начальных элементов и&nbsp;вывести их&nbsp;значения (если очередь содержит менее N&nbsp;элементов, то&nbsp;извлечь все ее&nbsp;элементы). Вывести также новые адреса начала и&nbsp;конца очереди (для&nbsp;пустой очереди дважды вывести nil). После извлечения элементов из&nbsp;очереди освобождать память, которую они занимали.</p>
<p class="tsk"><font face="Arial">Pointer20</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;начало и&nbsp;конец непустой очереди. Извлекать из&nbsp;очереди элементы, пока&nbsp;значение начального элемента очереди не&nbsp;станет четным, и&nbsp;выводить значения извлеченных элементов (если очередь не&nbsp;содержит элементов с&nbsp;четными значениями, то&nbsp;извлечь все ее&nbsp;элементы). Вывести также новые адреса начала и&nbsp;конца очереди (для&nbsp;пустой очереди дважды вывести nil). После извлечения элементов из&nbsp;очереди освобождать память, которую они занимали.</p>
<p class="tsk"><font face="Arial">Pointer21</font>. Даны две очереди; адреса начала и&nbsp;конца первой равны&nbsp;P1 и&nbsp;P2, а&nbsp;второй&nbsp;&#151; P3 и&nbsp;P4 (если&nbsp;очередь является пустой, то&nbsp;соответствующие адреса равны&nbsp;nil). Переместить все&nbsp;элементы первой очереди (в&nbsp;порядке от&nbsp;начала к&nbsp;концу) в&nbsp;конец второй очереди и&nbsp;вывести новые адреса начала и&nbsp;конца второй очереди. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer22</font>. Дано число&nbsp;N (&gt;&nbsp;0) и&nbsp;две&nbsp;непустые очереди; адреса начала и&nbsp;конца первой равны P1 и&nbsp;P2, а&nbsp;второй&nbsp;&#151; P3 и&nbsp;P4. Переместить N&nbsp;начальных элементов первой очереди в&nbsp;конец второй очереди. Если первая очередь содержит менее N&nbsp;элементов, то&nbsp;переместить из&nbsp;первой очереди во&nbsp;вторую все&nbsp;элементы. Вывести новые адреса начала и&nbsp;конца первой, а&nbsp;затем второй очереди (для&nbsp;пустой очереди дважды вывести&nbsp;nil). Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer23</font>. Даны две непустые очереди; адреса начала и&nbsp;конца первой равны&nbsp;P1 и&nbsp;P2, а&nbsp;второй&nbsp;&#151; P3 и&nbsp;P4. Перемещать элементы из&nbsp;начала первой очереди в&nbsp;конец второй, пока&nbsp;значение начального элемента первой очереди не&nbsp;станет четным (если первая очередь не&nbsp;содержит четных элементов, то&nbsp;переместить из&nbsp;первой очереди во&nbsp;вторую все&nbsp;элементы). Вывести новые адреса начала и&nbsp;конца первой, а&nbsp;затем второй очереди (для&nbsp;пустой очереди дважды вывести&nbsp;nil). Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer24</font>. Даны две непустые очереди; адреса начала и&nbsp;конца первой равны&nbsp;P1 и&nbsp;P2, а&nbsp;второй&nbsp;&#151; P3 и&nbsp;P4. Очереди содержат одинаковое количество элементов. Объединить очереди в&nbsp;одну, в&nbsp;которой элементы исходных очередей чередуются (начиная с&nbsp;первого элемента первой очереди). Вывести указатели на&nbsp;начало и&nbsp;конец полученной очереди. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer25</font>. Даны две непустые очереди; адреса начала и&nbsp;конца первой равны&nbsp;P1 и&nbsp;P2, а&nbsp;второй&nbsp;&#151; P3 и&nbsp;P4. Элементы каждой из&nbsp;очередей упорядочены по&nbsp;возрастанию (в&nbsp;направлении от&nbsp;начала очереди к&nbsp;концу). Объединить очереди в&nbsp;одну с&nbsp;сохранением упорядоченности элементов. Вывести указатели на&nbsp;начало и&nbsp;конец полученной очереди. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer26</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;начало и&nbsp;конец очереди (если очередь является пустой, то&nbsp;P1&nbsp;=&nbsp;P2&nbsp;=&nbsp;nil). Также дано число&nbsp;N (&gt;&nbsp;0) и&nbsp;набор из&nbsp;N&nbsp;чисел. Описать тип TQueue&nbsp;&#151; запись с&nbsp;двумя полями типа PNode: Head (начало очереди) и&nbsp;Tail (конец очереди)&nbsp;&#151; и&nbsp;процедуру Enqueue(Q,&nbsp;D), которая добавляет в&nbsp;конец очереди&nbsp;Q новый элемент со&nbsp;значением&nbsp;D (Q&nbsp;&#151; входной и&nbsp;выходной параметр типа TQueue, D&nbsp;&#151; входной параметр целого типа). С&nbsp;помощью процедуры Enqueue добавить в&nbsp;исходную очередь данный набор чисел и&nbsp;вывести новые адреса ее&nbsp;начала и&nbsp;конца.</p>
<p class="tsk"><font face="Arial">Pointer27</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;начало и&nbsp;конец очереди, содержащей не&nbsp;менее пяти элементов. Используя тип TQueue (см. задание Pointer26), описать функцию Dequeue(Q) целого типа, которая извлекает из&nbsp;очереди первый (начальный) элемент, возвращает его&nbsp;значение и&nbsp;освобождает память, занимаемую извлеченным элементом (Q&nbsp;&#151; входной и&nbsp;выходной параметр типа TQueue). С&nbsp;помощью функции Dequeue извлечь из&nbsp;исходной очереди пять&nbsp;начальных элементов и&nbsp;вывести их&nbsp;значения. Вывести также адреса начала и&nbsp;конца результирующей очереди (если&nbsp;очередь окажется пустой, то&nbsp;эти адреса должны быть равны&nbsp;nil).</p>
<p class="tsk"><font face="Arial">Pointer28</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;начало и&nbsp;конец очереди. Используя тип TQueue (см. задание Pointer26), описать функцию QueueIsEmpty(Q) логического типа, которая возвращает True, если очередь&nbsp;Q пуста, и&nbsp;False в&nbsp;противном случае (Q&nbsp;&#151; входной параметр типа TQueue). Используя эту функцию для&nbsp;проверки состояния очереди, а&nbsp;также функцию Dequeue из&nbsp;задания Pointer27, извлечь из&nbsp;исходной очереди пять&nbsp;начальных элементов (или&nbsp;все содержащиеся в&nbsp;ней элементы, если их&nbsp;менее пяти) и&nbsp;вывести их&nbsp;значения. Вывести также значение функции QueueIsEmpty для&nbsp;полученной очереди и&nbsp;новые адреса ее&nbsp;начала и&nbsp;конца.</p>
<p class="cmt"><h2>Двусвязные списки</h2></p>
<p class="tsk"><font face="Arial">Pointer29</font>. Дан адрес P2 записи типа TNode, содержащей поле Data (целого типа) и&nbsp;поля Prev и&nbsp;Next (типа PNode&nbsp;&#151; указателя на&nbsp;TNode). Эта запись связана полями Prev и&nbsp;Next соответственно с&nbsp;предыдущей и&nbsp;последующей записью того&nbsp;же типа. Вывести значения полей Data предыдущей и&nbsp;последующей записи, а&nbsp;также адреса&nbsp;P1 и&nbsp;P3 предыдущей и&nbsp;последующей записи.</p>
<p class="tsk"><font face="Arial">Pointer30*</font>. Дан указатель P1 на&nbsp;начало непустой цепочки элементов-записей типа TNode, связанных между собой с&nbsp;помощью поля Next. Используя поле Prev записи TNode, преобразовать исходную (односвязную) цепочку в&nbsp;двусвязную, в&nbsp;которой каждый элемент связан не&nbsp;только с&nbsp;последующим элементом (с&nbsp;помощью поля Next), но&nbsp;и&nbsp;с&nbsp;предыдущим (с&nbsp;помощью поля Prev). Поле Prev первого элемента положить равным&nbsp;nil. Вывести указатель на&nbsp;последний элемент преобразованной цепочки.</p>
<p class="cmt">В&nbsp;заданиях Pointer31&#150;Pointer69 структура "двусвязный список" (doubly linked list) моделируется цепочкой узлов-записей типа TNode, связанных как с&nbsp;предыдущим, так и&nbsp;с&nbsp;последующим узлом (см.&nbsp;задание Pointer30). Поле Next последнего элемента цепочки и&nbsp;поле Prev первого элемента цепочки равны&nbsp;nil. Для&nbsp;доступа к&nbsp;любому элементу двусвязного списка достаточно иметь указатель на&nbsp;один из&nbsp;его&nbsp;элементов, однако для&nbsp;ускорения операций со&nbsp;списком обычно хранят три&nbsp;указателя: на&nbsp;первый элемент списка (first), на&nbsp;его&nbsp;последний элемент (last) и&nbsp;на&nbsp;текущий элемент (current). Для&nbsp;пустого списка все эти&nbsp;указатели полагаются равными&nbsp;nil. Как&nbsp;в&nbsp;случае стека и&nbsp;очереди, значением элемента списка считается значение его&nbsp;поля&nbsp;Data.</p>
<p class="tsk"><font face="Arial">Pointer31</font>. Дан указатель&nbsp;P0 на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Вывести число&nbsp;N&nbsp;&#151; количество элементов в&nbsp;списке, а&nbsp;также указатели&nbsp;P1 и&nbsp;P2 на&nbsp;первый и&nbsp;последний элементы списка.</p>
<p class="tsk"><font face="Arial">Pointer32</font>. Даны числа&nbsp;D1 и&nbsp;D2 и&nbsp;указатель&nbsp;P0 на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Добавить в&nbsp;начало списка новый элемент со&nbsp;значением&nbsp;D1, а&nbsp;в&nbsp;конец&nbsp;&#151; новый элемент со&nbsp;значением&nbsp;D2. Вывести адреса первого и&nbsp;последнего элементов полученного списка.</p>
<p class="tsk"><font face="Arial">Pointer33</font>. Дано число&nbsp;D и&nbsp;указатель&nbsp;P0 на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Вставить перед данным элементом списка новый элемент со&nbsp;значением&nbsp;D и&nbsp;вывести указатель на&nbsp;добавленный элемент списка.</p>
<p class="tsk"><font face="Arial">Pointer34</font>. Дано число&nbsp;D и&nbsp;указатель&nbsp;P0 на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Вставить после данного элемента списка новый элемент со&nbsp;значением&nbsp;D и&nbsp;вывести указатель на&nbsp;добавленный элемент списка.</p>
<p class="tsk"><font face="Arial">Pointer35</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;первый и&nbsp;последний элементы двусвязного списка, содержащего не&nbsp;менее двух элементов. Продублировать в&nbsp;списке первый и&nbsp;последний элементы (новые элементы добавлять перед существующими элементами с&nbsp;такими же&nbsp;значениями) и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка.</p>
<p class="tsk"><font face="Arial">Pointer36</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;первый и&nbsp;последний элементы двусвязного списка, содержащего не&nbsp;менее двух элементов. Продублировать в&nbsp;списке первый и&nbsp;последний элементы (новые элементы добавлять после существующих элементов с&nbsp;такими же&nbsp;значениями) и&nbsp;вывести указатель на&nbsp;последний элемент преобразованного списка.</p>
<p class="tsk"><font face="Arial">Pointer37</font>. Дан указатель&nbsp;P1 на&nbsp;первый элемент непустого двусвязного списка. Продублировать в&nbsp;списке все&nbsp;элементы с&nbsp;нечетными номерами (новые элементы добавлять перед существующими элементами с&nbsp;такими же&nbsp;значениями) и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка.</p>
<p class="tsk"><font face="Arial">Pointer38</font>. Дан указатель&nbsp;P1 на&nbsp;первый элемент непустого двусвязного списка. Продублировать в&nbsp;списке все&nbsp;элементы с&nbsp;нечетными номерами (новые элементы добавлять после существующих элементов с&nbsp;такими же&nbsp;значениями) и&nbsp;вывести указатель на&nbsp;последний элемент преобразованного списка.</p>
<p class="tsk"><font face="Arial">Pointer39</font>. Дан указатель&nbsp;P1 на&nbsp;первый элемент непустого двусвязного списка. Продублировать в&nbsp;списке все&nbsp;элементы с&nbsp;нечетными значениями (новые элементы добавлять перед существующими элементами с&nbsp;такими&nbsp;же значениями) и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка.</p>
<p class="tsk"><font face="Arial">Pointer40</font>. Дан указатель&nbsp;P1 на&nbsp;первый элемент непустого двусвязного списка. Продублировать в&nbsp;списке все&nbsp;элементы с&nbsp;нечетными значениями (новые элементы добавлять после существующих элементов с&nbsp;такими&nbsp;же значениями) и&nbsp;вывести указатель на&nbsp;последний элемент преобразованного списка.</p>
<p class="tsk"><font face="Arial">Pointer41</font>. Дан указатель&nbsp;P0 на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Удалить из&nbsp;списка данный элемент и&nbsp;вывести два указателя: на&nbsp;элемент, предшествующий удаленному, и&nbsp;на&nbsp;элемент, следующий за&nbsp;удаленным (один или&nbsp;оба этих элемента могут отсутствовать; для&nbsp;отсутствующих элементов выводить&nbsp;nil). После удаления элемента из&nbsp;списка освободить память, занимаемую этим&nbsp;элементом.</p>
<p class="tsk"><font face="Arial">Pointer42</font>. Дан указатель&nbsp;P1 на&nbsp;первый элемент двусвязного списка, содержащего не&nbsp;менее двух&nbsp;элементов. Удалить из&nbsp;списка все&nbsp;элементы с&nbsp;нечетными номерами и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка. После удаления элементов из&nbsp;списка освобождать память, которую они занимали.</p>
<p class="tsk"><font face="Arial">Pointer43</font>. Дан указатель&nbsp;P1 на&nbsp;первый элемент непустого двусвязного списка. Удалить из&nbsp;списка все&nbsp;элементы с&nbsp;нечетными значениями и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка (если в&nbsp;результате удаления элементов список окажется пустым, то&nbsp;вывести&nbsp;nil). После удаления элементов из&nbsp;списка освобождать память, которую они занимали.</p>
<p class="tsk"><font face="Arial">Pointer44</font>. Дан указатель&nbsp;P0 на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Переместить данный элемент в&nbsp;конец списка и&nbsp;вывести указатели на&nbsp;первый и&nbsp;последний элементы преобразованного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer45</font>. Дан указатель&nbsp;P0 на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Переместить данный элемент в&nbsp;начало списка и&nbsp;вывести указатели на&nbsp;первый и&nbsp;последний элементы преобразованного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer46</font>. Дано число&nbsp;K (&gt;&nbsp;0) и&nbsp;указатель&nbsp;P0 на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Переместить в&nbsp;списке данный элемент на&nbsp;K&nbsp;позиций вперед (если после данного элемента находится менее&nbsp;K&nbsp;элементов, то&nbsp;переместить его&nbsp;в&nbsp;конец списка). Вывести указатели на&nbsp;первый и&nbsp;последний элементы преобразованного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer47</font>. Дано число&nbsp;K (&gt;&nbsp;0) и&nbsp;указатель&nbsp;P0 на&nbsp;один из&nbsp;элементов непустого двусвязного списка. Переместить в&nbsp;списке данный элемент на&nbsp;K&nbsp;позиций назад (если перед данным элементом находится менее&nbsp;K&nbsp;элементов, то&nbsp;переместить его&nbsp;в&nbsp;начало списка). Вывести указатели на&nbsp;первый и&nbsp;последний элементы преобразованного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer48</font>. Даны указатели&nbsp;PX и&nbsp;PY на&nbsp;два различных элемента двусвязного списка (элемент с&nbsp;адресом&nbsp;PX находится в&nbsp;списке перед элементом с&nbsp;адресом&nbsp;PY, но&nbsp;не&nbsp;обязательно рядом с&nbsp;ним). Поменять местами данные элементы и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer49*</font>. Дан указатель&nbsp;P1 на&nbsp;первый элемент непустого двусвязного списка. Перегруппировать его&nbsp;элементы, переместив все&nbsp;элементы с&nbsp;нечетными номерами в&nbsp;конец списка (в&nbsp;том&nbsp;же порядке) и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer50</font>. Дан указатель&nbsp;P1 на&nbsp;первый элемент непустого двусвязного списка. Перегруппировать его&nbsp;элементы, переместив все&nbsp;элементы с&nbsp;нечетными значениями в&nbsp;конец списка (в&nbsp;том&nbsp;же порядке) и&nbsp;вывести указатель на&nbsp;первый элемент преобразованного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать, поля Data не&nbsp;изменять.</p>
<p class="tsk"><font face="Arial">Pointer51</font>. Даны два непустых двусвязных списка и&nbsp;связанные с&nbsp;ними указатели:&nbsp;PA и&nbsp;PB указывают на&nbsp;первый и&nbsp;последний элементы первого списка, PC&nbsp;&#151; на&nbsp;один из&nbsp;элементов второго. Объединить исходные списки, поместив все&nbsp;элементы первого списка (в&nbsp;том&nbsp;же порядке) перед данным элементом второго списка, и&nbsp;вывести указатели на&nbsp;первый и&nbsp;последний элементы объединенного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer52</font>. Даны два непустых двусвязных списка и&nbsp;связанные с&nbsp;ними указатели:&nbsp;PA и&nbsp;PB указывают на&nbsp;первый и&nbsp;последний элементы первого списка, PC&nbsp;&#151; на&nbsp;один из&nbsp;элементов второго. Объединить исходные списки, поместив все&nbsp;элементы первого списка (в&nbsp;том&nbsp;же порядке) после данного элемента второго списка, и&nbsp;вывести указатели на&nbsp;первый и&nbsp;последний элементы объединенного списка. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer53</font>. Даны указатели&nbsp;PX и&nbsp;PY на&nbsp;два различных элемента двусвязного списка; элемент с&nbsp;адресом&nbsp;PX находится в&nbsp;списке перед элементом с&nbsp;адресом&nbsp;PY, но&nbsp;не&nbsp;обязательно рядом с&nbsp;ним. Переместить элементы, расположенные между данными элементами (включая данные элементы) в&nbsp;новый список (в&nbsp;том&nbsp;же порядке). Вывести указатели на&nbsp;первые элементы преобразованного и&nbsp;нового списков. Если преобразованный список окажется пустым, то&nbsp;связанный с&nbsp;ним указатель положить равным&nbsp;nil. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer54</font>. Даны указатели&nbsp;PX и&nbsp;PY на&nbsp;два различных элемента двусвязного списка; элемент с&nbsp;адресом&nbsp;PX находится в&nbsp;списке перед элементом с&nbsp;адресом&nbsp;PY, но&nbsp;не&nbsp;обязательно рядом с&nbsp;ним. Переместить элементы, расположенные между данными элементами (не включая данные элементы) в&nbsp;новый список (в&nbsp;том&nbsp;же порядке). Вывести указатели на&nbsp;первые элементы преобразованного и&nbsp;нового списков. Если новый список окажется пустым, то&nbsp;связанный с&nbsp;ним указатель положить равным&nbsp;nil. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer55*</font>. Дан указатель&nbsp;P1 на&nbsp;первый элемент непустого двусвязного списка. Преобразовать список в&nbsp;циклический, связав его&nbsp;последний элемент с&nbsp;помощью поля Next с&nbsp;первым, а&nbsp;первый элемент с&nbsp;помощью поля Prev&nbsp;&#151; с&nbsp;последним, и&nbsp;вывести указатель на&nbsp;элемент, который был последним элементом исходного списка.</p>
<p class="tsk"><font face="Arial">Pointer56</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;первый и&nbsp;последний элементы непустого двусвязного списка, содержащего четное количество элементов. Преобразовать список в&nbsp;два циклических списка (см.&nbsp;задание Pointer55), первый из&nbsp;которых содержит первую половину элементов исходного списка, а&nbsp;второй&nbsp;&#151; вторую половину. Вывести указатели&nbsp;PA и&nbsp;PB на&nbsp;два средних элемента исходного списка (элемент с&nbsp;адресом&nbsp;PA должен входить в&nbsp;первый циклический список, а&nbsp;элемент с&nbsp;адресом&nbsp;PB&nbsp;&#151; во&nbsp;второй). Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer57</font>. Дано число&nbsp;K (&gt;&nbsp;0) и&nbsp;указатели&nbsp;P1 и&nbsp;P2 на&nbsp;первый и&nbsp;последний элементы непустого двусвязного списка. Осуществить циклический сдвиг элементов списка на&nbsp;K&nbsp;позиций вперед (то&nbsp;есть в&nbsp;направлении от&nbsp;начала к&nbsp;концу списка) и&nbsp;вывести указатели на&nbsp;первый и&nbsp;последний элементы полученного списка. Для выполнения циклического сдвига преобразовать исходный список в&nbsp;циклический (см.&nbsp;задание Pointer55), после чего "разорвать" его в&nbsp;позиции, соответствующей данному значению&nbsp;K. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer58</font>. Дано число&nbsp;K (&gt;&nbsp;0) и&nbsp;указатели&nbsp;P1 и&nbsp;P2 на&nbsp;первый и&nbsp;последний элементы непустого двусвязного списка. Осуществить циклический сдвиг элементов списка на&nbsp;K&nbsp;позиций назад (то&nbsp;есть в&nbsp;направлении от&nbsp;конца к&nbsp;началу списка) и&nbsp;вывести указатели на&nbsp;первый и&nbsp;последний элементы полученного списка. Для выполнения циклического сдвига преобразовать исходный список в&nbsp;циклический (см.&nbsp;задание Pointer55), после чего "разорвать" его в&nbsp;позиции, соответствующей данному значению&nbsp;K. Операции выделения и&nbsp;освобождения памяти не&nbsp;использовать.</p>
<p class="tsk"><font face="Arial">Pointer59</font>. Даны указатели&nbsp;P1, P2 и&nbsp;P3 на&nbsp;первый, последний и&nbsp;текущий элементы двусвязного списка (если&nbsp;список является пустым, то&nbsp;P1&nbsp;=&nbsp;P2&nbsp;=&nbsp;P3&nbsp;=&nbsp;nil). Также дано число&nbsp;N&nbsp;(&gt;&nbsp;0) и&nbsp;набор из&nbsp;N&nbsp;чисел. Описать тип TList&nbsp;&#151; запись с&nbsp;полями First, Last и Current типа PNode (поля указывают соответственно на&nbsp;первый, последний и&nbsp;текущий элементы списка)&nbsp;&#151; и&nbsp;процедуру InsertLast(L,&nbsp;D), которая добавляет новый элемент со&nbsp;значением&nbsp;D в&nbsp;конец списка&nbsp;L (L&nbsp;&#151; входной и&nbsp;выходной параметр типа TList, D&nbsp;&#151; входной параметр целого типа). Добавленный элемент становится текущим. С&nbsp;помощью этой&nbsp;процедуры добавить в&nbsp;конец исходного списка данный набор чисел (в&nbsp;том&nbsp;же порядке) и&nbsp;вывести новые адреса его&nbsp;первого, последнего и&nbsp;текущего элементов.</p>
<p class="tsk"><font face="Arial">Pointer60</font>. Даны указатели&nbsp;P1, P2 и&nbsp;P3 на&nbsp;первый, последний и&nbsp;текущий элементы двусвязного списка (если&nbsp;список является пустым, то&nbsp;P1&nbsp;=&nbsp;P2&nbsp;=&nbsp;P3&nbsp;=&nbsp;nil). Также дано число&nbsp;N&nbsp;(&gt;&nbsp;0) и&nbsp;набор из&nbsp;N&nbsp;чисел. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуру InsertFirst(L,&nbsp;D), которая добавляет новый элемент со&nbsp;значением&nbsp;D в&nbsp;начало списка&nbsp;L (L&nbsp;&#151; входной и&nbsp;выходной параметр типа TList, D&nbsp;&#151; входной параметр целого типа). Добавленный элемент становится текущим. С&nbsp;помощью этой процедуры добавить в&nbsp;начало исходного списка данный набор чисел (добавленные числа будут располагаться в&nbsp;списке в&nbsp;обратном порядке) и&nbsp;вывести новые адреса его&nbsp;первого, последнего и&nbsp;текущего элементов.</p>
<p class="tsk"><font face="Arial">Pointer61</font>. Дан непустой двусвязный список, первый, последний и&nbsp;текущий элементы которого имеют адреса&nbsp;P1, P2 и&nbsp;P3. Также даны пять чисел. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуру InsertBefore(L,&nbsp;D), которая вставляет новый элемент со&nbsp;значением&nbsp;D перед текущим элементом списка&nbsp;L (L&nbsp;&#151; входной и&nbsp;выходной параметр типа TList, D&nbsp;&#151; входной параметр целого типа). Вставленный элемент становится текущим. С&nbsp;помощью этой&nbsp;процедуры вставить пять данных чисел в&nbsp;исходный список и&nbsp;вывести новые адреса его&nbsp;первого, последнего и&nbsp;текущего элементов.</p>
<p class="tsk"><font face="Arial">Pointer62</font>. Дан непустой двусвязный список, первый, последний и&nbsp;текущий элементы которого имеют адреса&nbsp;P1, P2 и&nbsp;P3. Также даны пять чисел. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуру InsertAfter(L,&nbsp;D), которая вставляет новый элемент со&nbsp;значением&nbsp;D после текущего элемента списка&nbsp;L (L&nbsp;&#151; входной и&nbsp;выходной параметр типа TList, D&nbsp;&#151; входной параметр целого типа). Вставленный элемент становится текущим. С&nbsp;помощью этой&nbsp;процедуры вставить пять данных чисел в&nbsp;исходный список и&nbsp;вывести новые адреса его&nbsp;первого, последнего и&nbsp;текущего элементов.</p>
<p class="tsk"><font face="Arial">Pointer63</font>. Дан непустой двусвязный список, первый, последний и&nbsp;текущий элементы которого имеют адреса&nbsp;P1, P2 и&nbsp;P3. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуры ToFirst(L) (делает текущим первый элемент списка&nbsp;L), ToNext(L) (делает текущим в&nbsp;списке&nbsp;L следующий элемент, если&nbsp;он&nbsp;существует), SetData(L,&nbsp;D) (присваивает текущему элементу списка&nbsp;L значение&nbsp;D целого типа) и&nbsp;функцию IsLast(L) логического типа (возвращает True, если&nbsp;текущий элемент списка&nbsp;L является его&nbsp;последним элементом, и&nbsp;False в&nbsp;противном случае). Параметр&nbsp;L имеет тип TList; в&nbsp;процедурах ToFirst и&nbsp;ToNext он является входным и&nbsp;выходным. С&nbsp;помощью этих процедур и функций присвоить нулевые значения элементам исходного списка с&nbsp;нечетными номерами и&nbsp;вывести количество элементов в&nbsp;списке, а&nbsp;также новый адрес текущего элемента списка.</p>
<p class="tsk"><font face="Arial">Pointer64</font>. Дан непустой двусвязный список, первый, последний и&nbsp;текущий элементы которого имеют адреса&nbsp;P1, P2 и&nbsp;P3. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуры ToLast(L) (делает текущим последний элемент списка&nbsp;L), ToPrev(L) (делает текущим в&nbsp;списке&nbsp;L предыдущий элемент, если он&nbsp;существует) и&nbsp;функции GetData(L) целого типа (возвращает значение текущего элемента списка&nbsp;L), IsFirst(L) логического типа (возвращает True, если текущий элемент списка&nbsp;L является его&nbsp;первым элементом, и&nbsp;False в&nbsp;противном случае). Параметр&nbsp;L имеет тип TList; в&nbsp;процедурах ToLast и&nbsp;ToPrev он является входным и&nbsp;выходным. С&nbsp;помощью этих процедур и функций вывести все&nbsp;четные значения элементов исходного списка, просматривая список с&nbsp;конца. Вывести также количество элементов в&nbsp;списке.</p>
<p class="tsk"><font face="Arial">Pointer65</font>. Даны указатели&nbsp;P1, P2 и&nbsp;P3 на&nbsp;первый, последний и&nbsp;текущий элементы двусвязного списка, содержащего не&nbsp;менее пяти&nbsp;элементов. Используя тип TList (см.&nbsp;задание Pointer59), описать функцию DeleteCurrent(L) целого типа, удаляющую из&nbsp;списка&nbsp;L текущий элемент и&nbsp;возвращающую его&nbsp;значение (L&nbsp;&#151; входной и&nbsp;выходной параметр типа TList). После удаления элемента текущим становится следующий элемент или, если&nbsp;следующего элемента не&nbsp;существует, последний элемент списка. Функция также освобождает память, занимаемую удаленным элементом. С&nbsp;помощью этой&nbsp;функции удалить из&nbsp;исходного списка пять&nbsp;элементов и&nbsp;вывести их&nbsp;значения. Вывести также новые адреса первого, последнего и&nbsp;текущего элементов списка.</p>
<p class="tsk"><font face="Arial">Pointer66</font>. Даны указатели&nbsp;P1, P2 и&nbsp;P3 на&nbsp;первый, последний и&nbsp;текущий элементы непустого двусвязного списка. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуру SplitList(L1,&nbsp;L2), которая переносит элементы списка&nbsp;L1 от&nbsp;текущего до&nbsp;последнего в&nbsp;новый список&nbsp;L2 (таким образом, список&nbsp;L1 делится на&nbsp;две части, причем первая часть может оказаться пустой). Параметры процедуры имеют тип TList; первый параметр является входным и&nbsp;выходным, второй&nbsp;&#151; выходным. Текущими элементами непустых результирующих списков становятся их&nbsp;первые элементы. Операции выделения и&nbsp;освобождения памяти в&nbsp;процедуре не&nbsp;использовать. С&nbsp;помощью этой&nbsp;процедуры разбить исходный список на&nbsp;два и&nbsp;вывести адреса первого, последнего и&nbsp;текущего элементов полученных списков.</p>
<p class="tsk"><font face="Arial">Pointer67</font>. Даны указатели на&nbsp;первый, последний и&nbsp;текущий элементы двух&nbsp;непустых двусвязных списков. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуру AddList(L1,&nbsp;L2), которая добавляет все&nbsp;элементы из&nbsp;списка&nbsp;L2 (в&nbsp;том&nbsp;же порядке) в&nbsp;конец списка&nbsp;L1; в&nbsp;результате список&nbsp;L2 становится пустым. Текущим элементом списка&nbsp;L1 становится первый из&nbsp;добавленных элементов. Оба параметра процедуры имеют тип TList и&nbsp;являются входными и&nbsp;выходными. Операции выделения и&nbsp;освобождения памяти в&nbsp;процедуре не&nbsp;использовать. С&nbsp;помощью этой&nbsp;процедуры добавить второй из&nbsp;исходных списков в&nbsp;конец первого и&nbsp;вывести адреса первого, последнего и&nbsp;текущего элементов объединенного списка.</p>
<p class="tsk"><font face="Arial">Pointer68</font>. Даны указатели на&nbsp;первый, последний и&nbsp;текущий элементы двух&nbsp;непустых двусвязных списков. Используя тип TList (см.&nbsp;задание Pointer59), описать процедуру InsertList(L1,&nbsp;L2), которая вставляет все&nbsp;элементы из&nbsp;списка&nbsp;L2 (в&nbsp;том&nbsp;же порядке) в&nbsp;список&nbsp;L1 перед его&nbsp;текущим элементом; в&nbsp;результате список&nbsp;L2 становится пустым. Текущим элементом списка&nbsp;L1 становится первый из&nbsp;вставленных элементов. Оба параметра процедуры имеют тип TList и&nbsp;являются входными и&nbsp;выходными. Операции выделения и&nbsp;освобождения памяти в&nbsp;процедуре не&nbsp;использовать. С&nbsp;помощью этой&nbsp;процедуры вставить второй из&nbsp;исходных списков в&nbsp;текущую позицию первого и&nbsp;вывести адреса первого, последнего и&nbsp;текущего элементов объединенного списка.</p>
<p class="tsk"><font face="Arial">Pointer69</font>. Даны указатели на&nbsp;первый, последний и&nbsp;текущий элементы двух&nbsp;двусвязных списков (второй список может быть пустым). Используя тип TList (см.&nbsp;задание Pointer59), описать процедуру MoveCurrent(L1,&nbsp;L2), которая перемещает текущий элемент списка&nbsp;L1 в&nbsp;список&nbsp;L2 (элемент вставляется после текущего элемента списка&nbsp;L2 и&nbsp;сам становится текущим; в&nbsp;списке&nbsp;L1 текущим становится следующий элемент или, если&nbsp;следующего элемента не&nbsp;существует, последний элемент). Оба параметра процедуры имеют тип TList и&nbsp;являются входными и&nbsp;выходными. Операции выделения и&nbsp;освобождения памяти в&nbsp;процедуре не&nbsp;использовать. С&nbsp;помощью этой&nbsp;процедуры переместить текущий элемент первого списка во&nbsp;второй и&nbsp;вывести адреса первого, последнего и&nbsp;текущего элементов полученных списков.</p>
<p class="cmt">Использованная в&nbsp;заданиях Pointer31&#150;Pointer69 реализация двусвязного списка в&nbsp;виде цепочки узлов, ограниченной по&nbsp;краям нулевыми указателями, не&nbsp;является единственно возможной. Двусвязный список можно также реализовать в&nbsp;виде замкнутой цепочки узлов с&nbsp;дополнительным фиктивным, или&nbsp;барьерным, элементом. Этот&nbsp;барьерный элемент связан своими полями Next и&nbsp;Prev с&nbsp;первым и&nbsp;последним "настоящим" элементом списка соответственно, поэтому, имея указатель на&nbsp;барьерный элемент, можно сразу перейти как к&nbsp;первому, так и&nbsp;к&nbsp;последнему элементу списка (естественно, первый и&nbsp;последний элементы также связаны с&nbsp;барьерным элементом своими полями Prev и Next соответственно). Для&nbsp;работы с&nbsp;двусвязным списком, снабженным барьерным элементом, достаточно хранить два&nbsp;указателя: Barrier, указывающий на&nbsp;барьерный элемент, и&nbsp;Current, указывающий на&nbsp;текущий элемент (который может быть как&nbsp;"настоящим", так и&nbsp;барьерным элементом). Поле Data барьерного элемента может быть произвольным; для&nbsp;определенности его обычно полагают равным&nbsp;0. Пустой список в&nbsp;данной реализации представляет собой единственный барьерный элемент, "замкнутый на&nbsp;себя".</p>
<p class="cmt">Задания Pointer70&#150;Pointer80 посвящены двусвязным спискам с&nbsp;барьерным элементом.</p>
<p class="tsk"><font face="Arial">Pointer70</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;первый и&nbsp;последний элементы двусвязного списка, реализованного в&nbsp;виде цепочки узлов, ограниченной по&nbsp;краям нулевыми указателями (если&nbsp;список пуст, то&nbsp;P1&nbsp;=&nbsp;P2&nbsp;=&nbsp;nil). Преобразовать исходный список в&nbsp;циклический список (см.&nbsp;задание Pointer55), снабженный барьерным элементом. Барьерный элемент должен иметь значение&nbsp;0 и&nbsp;быть связан своими полями Next и&nbsp;Prev с&nbsp;первым и&nbsp;последним элементом исходного списка (в&nbsp;случае пустого исходного списка поля Next и&nbsp;Prev барьерного элемента должны указывать на&nbsp;сам&nbsp;барьерный элемент). Вывести указатель на&nbsp;барьерный элемент полученного списка. Операцию выделения памяти использовать только для&nbsp;создания барьерного элемента.</p>
<p class="tsk"><font face="Arial">Pointer71</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;барьерный и&nbsp;текущий элементы двусвязного списка (о&nbsp;списке с&nbsp;барьерным элементом см.&nbsp;задание Pointer70). Разбить список на&nbsp;два, перенеся во&nbsp;второй список все&nbsp;элементы от&nbsp;текущего до&nbsp;последнего и&nbsp;добавив ко&nbsp;второму списку барьерный элемент. Если&nbsp;текущий элемент исходного списка является барьерным элементом, то&nbsp;второй список должен быть пустым (то&nbsp;есть состоять только из&nbsp;барьерного элемента). Вывести указатель на&nbsp;барьерный элемент второго списка. Операцию выделения памяти использовать только для&nbsp;создания барьерного элемента второго списка.</p>
<p class="tsk"><font face="Arial">Pointer72</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;барьерные элементы двух двусвязных списков (о&nbsp;списке с&nbsp;барьерным элементом см.&nbsp;задание Pointer70). Объединить исходные списки, связав конец первого и&nbsp;начало второго списка (барьерным элементом объединенного списка должен остаться барьерный элемент первого списка). Вывести указатели на&nbsp;первый и&nbsp;последний элементы объединенного списка (если&nbsp;объединенный список является пустым, то&nbsp;дважды вывести указатель на&nbsp;его&nbsp;барьерный элемент). После удаления лишнего барьерного элемента освободить занимаемую им&nbsp;память.</p>
<p class="tsk"><font face="Arial">Pointer73</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;барьерные элементы двух двусвязных списков (о&nbsp;списке с&nbsp;барьерным элементом см.&nbsp;задание Pointer70). Объединить исходные списки, связав конец первого и&nbsp;начало второго списка (барьерным элементом объединенного списка должен остаться барьерный элемент второго списка). Вывести указатели на&nbsp;первый и&nbsp;последний элементы объединенного списка (если&nbsp;объединенный список является пустым, то&nbsp;дважды вывести указатель на&nbsp;его&nbsp;барьерный элемент). После удаления лишнего барьерного элемента освободить занимаемую им&nbsp;память.</p>
<p class="tsk"><font face="Arial">Pointer74</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;барьерный и&nbsp;текущий элементы двусвязного списка (о&nbsp;списке с&nbsp;барьерным элементом см.&nbsp;задание Pointer70). Также дано число&nbsp;N&nbsp;(&gt;&nbsp;0) и&nbsp;набор из&nbsp;N&nbsp;чисел. Описать тип TListB&nbsp;&#151; запись с&nbsp;полями Barrier и&nbsp;Current типа PNode (поля указывают соответственно на&nbsp;барьерный и&nbsp;текущий элементы списка)&nbsp;&#151; и&nbsp;процедуру LBInsertLast(L,&nbsp;D), которая добавляет новый элемент со&nbsp;значением&nbsp;D в&nbsp;конец списка&nbsp;L (L&nbsp;&#151; входной и&nbsp;выходной параметр типа TListB, D&nbsp;&#151; входной параметр целого типа). Добавленный элемент становится текущим. С&nbsp;помощью этой&nbsp;процедуры добавить в&nbsp;конец исходного списка данный набор чисел (в&nbsp;том&nbsp;же порядке) и&nbsp;вывести адрес текущего элемента полученного списка.</p>
<p class="tsk"><font face="Arial">Pointer75</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;барьерный и&nbsp;текущий элементы двусвязного списка. Также дано число&nbsp;N&nbsp;(&gt;&nbsp;0) и&nbsp;набор из&nbsp;N&nbsp;чисел. Используя тип TListB (см.&nbsp;задание Pointer74), описать процедуру LBInsertFirst(L,&nbsp;D), которая добавляет новый элемент со&nbsp;значением&nbsp;D в&nbsp;начало списка&nbsp;L (L&nbsp;&#151; входной и&nbsp;выходной параметр типа TListB, D&nbsp;&#151; входной параметр целого типа). Добавленный элемент становится текущим. С&nbsp;помощью этой&nbsp;процедуры добавить в&nbsp;начало исходного списка данный набор чисел (добавленные числа будут располагаться в&nbsp;списке в&nbsp;обратном порядке) и&nbsp;вывести адрес текущего элемента полученного списка.</p>
<p class="tsk"><font face="Arial">Pointer76</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;барьерный и&nbsp;текущий элементы двусвязного списка. Также даны пять чисел. Используя тип TListB (см.&nbsp;задание Pointer74), описать процедуру LBInsertBefore(L,&nbsp;D), которая вставляет новый элемент со&nbsp;значением&nbsp;D перед текущим элементом списка&nbsp;L (L&nbsp;&#151; входной и&nbsp;выходной параметр типа TListB, D&nbsp;&#151; входной параметр целого типа). Вставленный элемент становится текущим. С&nbsp;помощью этой&nbsp;процедуры вставить пять данных чисел в&nbsp;исходный список и&nbsp;вывести новый адрес его&nbsp;текущего элемента.</p>
<p class="tsk"><font face="Arial">Pointer77</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;барьерный и&nbsp;текущий элементы двусвязного списка. Также даны пять чисел. Используя тип TListB (см.&nbsp;задание Pointer74), описать процедуру LBInsertAfter(L,&nbsp;D), которая вставляет новый элемент со&nbsp;значением&nbsp;D после текущего элемента списка&nbsp;L (L&nbsp;&#151; входной и&nbsp;выходной параметр типа TListB, D&nbsp;&#151; входной параметр целого типа). Вставленный элемент становится текущим. С&nbsp;помощью этой&nbsp;процедуры вставить пять данных чисел в&nbsp;исходный список и&nbsp;вывести новый адрес его&nbsp;текущего элемента.</p>
<p class="tsk"><font face="Arial">Pointer78</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;барьерный и&nbsp;текущий элементы двусвязного списка. Используя тип TListB (см.&nbsp;задание Pointer74), описать процедуры LBToFirst(L) (делает текущим первый элемент списка&nbsp;L), LBToNext(L) (делает текущим в&nbsp;списке&nbsp;L следующий элемент), LBSetData(L,&nbsp;D) (присваивает текущему элементу списка&nbsp;L значение&nbsp;D целого типа, если&nbsp;данный элемент не&nbsp;является барьерным) и&nbsp;функцию IsBarrier(L) логического типа (возвращает True, если текущий элемент списка&nbsp;L является его&nbsp;барьерным элементом, и&nbsp;False в&nbsp;противном случае). Параметр&nbsp;L имеет тип TListB; в&nbsp;процедурах LBToFirst и&nbsp;LBToNext он является входным и&nbsp;выходным. С&nbsp;помощью этих процедур и функций присвоить нулевые значения элементам исходного списка с&nbsp;нечетными номерами и&nbsp;вывести количество элементов в&nbsp;списке, а&nbsp;также новый адрес текущего элемента списка. Барьерный элемент при&nbsp;подсчете элементов не&nbsp;учитывать.</p>
<p class="tsk"><font face="Arial">Pointer79</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;барьерный и&nbsp;текущий элементы двусвязного списка. Используя тип TListB (см.&nbsp;задание Pointer74), описать процедуры LBToLast(L) (делает текущим последний элемент списка&nbsp;L), LBToPrev(L) (делает текущим в&nbsp;списке&nbsp;L предыдущий элемент) и&nbsp;функцию LBGetData(L) целого типа (возвращает значение текущего элемента списка&nbsp;L). Параметр&nbsp;L имеет тип TListB; в&nbsp;процедурах LBToLast и&nbsp;LBToPrev он является входным и&nbsp;выходным. С&nbsp;помощью этих процедур и функций, а&nbsp;также с&nbsp;использованием функции IsBarrier из&nbsp;задания Pointer78, вывести все&nbsp;четные значения элементов исходного списка, просматривая список с&nbsp;конца. Вывести также количество элементов в&nbsp;списке. Барьерный элемент при&nbsp;подсчете элементов не&nbsp;учитывать.</p>
<p class="tsk"><font face="Arial">Pointer80</font>. Даны указатели&nbsp;P1 и&nbsp;P2 на&nbsp;барьерный и&nbsp;текущий элементы непустого двусвязного списка, причем текущий элемент не&nbsp;совпадает с барьерным. Используя тип TListB (см.&nbsp;задание Pointer74), описать функцию LBDeleteCurrent(L) целого типа, удаляющую из&nbsp;списка&nbsp;L текущий элемент и&nbsp;возвращающую его&nbsp;значение (L&nbsp;&#151; входной и выходной параметр типа TListB). Текущим становится следующий элемент или, если&nbsp;следующий элемент является барьерным, предыдущий элемент списка. Функция также освобождает память, занимаемую удаленным элементом. Если текущим элементом является барьерный элемент, то&nbsp;функция не&nbsp;выполняет никаких действий и&nbsp;возвращает&nbsp;0. С&nbsp;помощью этой&nbsp;функции, а&nbsp;также функции IsBarrier из&nbsp;задания Pointer78, удалить из&nbsp;исходного списка пять&nbsp;элементов (или&nbsp;все элементы, если их&nbsp;менее пяти) и&nbsp;вывести их&nbsp;значения. Вывести также новый адрес текущего элемента списка.</p>
<hr noshade><div align=right><font size=-1>Дата генерации страницы: 22.03.2005.</font></div></body></html>
