<!-- Programming Taskbook 4.4 | Copyright (c) M. Abramyan, 1998-2005 -->
<html><head><meta http-equiv="pragma" content="no-cache"><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>Programming Taskbook 4.4 | Рекурсия</title>
</head><body vlink="#003366" link="#003366"><style>
H1{font-family:"Arial";font-size:20pt;text-indent:0;margin-top:10; margin-right:10; margin-bottom:0; margin-left:10;}
H2{font-family:"Arial";font-size:16pt;text-indent:0;margin: 20 10 0 10;}
H3{font-family:"Arial";font-size:12pt;text-indent:0;margin: 20 10 0 10;}
P{font-family:"Times New Roman";font-size:12pt;text-indent:0;margin-top:0; margin-right:10; margin-bottom:0; margin-left:10;}
center{font-family:"Times New Roman";font-size:12pt;}
TABLE{margin-top:0; margin-bottom:0;}
TD{font-family:"Times New Roman";font-size:12pt;}
LI{font-family:"Times New Roman";font-size:12pt;}
UL{font-family:"Times New Roman";font-size:12pt;}
P.tsk{text-align:left;text-indent:-50;margin-top:5; margin-left:60;}
P.hnt{text-align:left;margin-left:60;}
P.hntc{text-align:left;margin-left:60;}
P.hntq{text-align:left;margin-left: 60;}
P.cmt{text-align:left;margin-top:5;}
P.ttt{text-align:left;}
P.cnt{text-align:center;}
P.qte{text-align:left;margin-left:120;margin-top:0;margin-bottom:0;}
blockquote{font-family:"Times New Roman";text-align:left;margin-left:100;margin-top:0; margin-bottom:0;}
P.cmtc{text-align:left;}
P.cmtq{text-align:left;}
SUB{font-family:"Times New Roman";font-size:8pt;}
SUP{font-family:"Times New Roman";font-size:8pt;}
P.foot{text-align:right;font-size:8pt;margin-right:0;}
</style>
<script language="javascript" src="back.js">
</script>
<font face="Arial" size=+3><b>Programming Taskbook 4</b><br></font>
<font face="Arial" size=+1>Электронный задачник по программированию</font>
<div align=right><font size = -1>&copy;&nbsp;&nbsp;М.&nbsp;Э.&nbsp;Абрамян,&nbsp;1998&#150;2005</font></div>
<hr noshade>
<div align=center><font size=-1>
[<a href="index.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/index.htm">Общее&nbsp;описание</a>] [<a href="remarks.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/remarks.htm">Предварительные&nbsp;замечания</a>] [<a href="begin.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/begin.htm">Ввод&nbsp;и&nbsp;вывод&nbsp;данных,&nbsp;оператор&nbsp;присваивания</a>] [<a href="integer.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/integer.htm">Целые&nbsp;числа</a>] [<a href="boolean.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/boolean.htm">Логические&nbsp;выражения</a>] [<a href="if.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/if.htm">Условный&nbsp;оператор</a>] [<a href="case.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/case.htm">Оператор&nbsp;выбора</a>] [<a href="for.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/for.htm">Цикл&nbsp;с&nbsp;параметром</a>] [<a href="while.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/while.htm">Цикл&nbsp;с&nbsp;условием</a>] [<a href="series.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/series.htm">Последовательности</a>] [<a href="proc.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/proc.htm">Процедуры&nbsp;и&nbsp;функции</a>] [<a href="minmax.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/minmax.htm">Минимумы&nbsp;и&nbsp;максимумы</a>] [<a href="array.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/array.htm">Одномерные&nbsp;массивы</a>] [<a href="matrix.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/matrix.htm">Двумерные&nbsp;массивы&nbsp;(матрицы)</a>] [<a href="string.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/string.htm">Символы&nbsp;и&nbsp;строки</a>] [<a href="file.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/file.htm">Двоичные&nbsp;(типизированные)&nbsp;файлы</a>] [<a href="text.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/text.htm">Текстовые&nbsp;файлы</a>] [<a href="param.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/param.htm">Составные&nbsp;типы&nbsp;данных&nbsp;в&nbsp;процедурах&nbsp;и&nbsp;функциях</a>] [<b>Рекурсия</b>] [<a href="pointer.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/pointer.htm">Указатели&nbsp;и&nbsp;динамические&nbsp;структуры&nbsp;данных</a>] [<a href="demo.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/demo.htm">Задания&nbsp;демо-версии</a>]
</font></div><hr noshade><div align=right><font size=-1>Стиль: [<a href="recurd.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/recurd.htm">DOS-программа</a>] [<a href="recurw.htm" tppabs="http://sunschool.math.rsu.ru/taskbook/recurw.htm">Windows-программа</a>] [<b>Книга</b>]</font></div>

<p class="cmt"><h1>Рекурсия</h1> <h2>Простейшие рекурсивные алгоритмы</h2></p>
<p class="cmt">Задания этого раздела можно легко решить и&nbsp;<i>без использования рекурсии</i>. Данное обстоятельство связано с&nbsp;тем, что в&nbsp;заданиях рассматриваются <i>простейшие</i> примеры рекурсии, легко сводимые к&nbsp;итерационным алгоритмам. Более того, в&nbsp;некоторых случаях непосредственные вычисления по рекурсивным формулам оказываются весьма неэффективными (см.,&nbsp;например, задания Recur4 и&nbsp;Recur6). Однако именно на&nbsp;подобных примерах проще всего получить первоначальные навыки разработки рекурсивных алгоритмов.</p>
<p class="tsk"><font face="Arial">Recur1*</font>. Описать рекурсивную функцию Fact(<i>N</i>) вещественного типа, вычисляющую значение <i>факториала</i></p><center><i>N</i>!&nbsp;=&nbsp;1&#183;2&#183;&#133;&#183;<i>N</i></center><p class="hntc">(<i>N</i>&nbsp;&gt;&nbsp;0&nbsp;&#151; параметр целого типа). С&nbsp;помощью этой функции вычислить факториалы пяти данных чисел.</p>
<p class="tsk"><font face="Arial">Recur2</font>. Описать рекурсивную функцию Fact2(<i>N</i>) вещественного типа, вычисляющую значение <i>двойного факториала</i></p><center><i>N</i>!!&nbsp;=&nbsp;<i>N</i>&#183;(<i>N</i>&#150;2)&#183;(<i>N</i>&#150;4)&#183;&#133;</center><p class="hntc">(<i>N</i>&nbsp;&gt;&nbsp;0&nbsp;&#151; параметр целого типа; последний сомножитель в&nbsp;произведении равен&nbsp;2, если <i>N</i>&nbsp;&#151; четное число, и&nbsp;1, если <i>N</i>&nbsp;&#151; нечетное). С&nbsp;помощью этой функции вычислить двойные факториалы пяти данных чисел.</p>
<p class="tsk"><font face="Arial">Recur3</font>. Описать рекурсивную функцию PowerN(<i>X</i>,&nbsp;<i>N</i>) вещественного типа, находящую значение <i>N</i>-й&nbsp;степени числа&nbsp;<i>X</i> по&nbsp;формулам: </p><center><i>X</i><sup>&nbsp;0</sup>&nbsp;=&nbsp;1,<br><i>X</i><sup>&nbsp;<i>N</i></sup>&nbsp;=&nbsp;(<i>X</i><sup>&nbsp;<i>N</i>/2</sup>)<sup>2</sup> при <i>четных</i> <i>N</i>&nbsp;&gt;&nbsp;0, &nbsp; &nbsp; &nbsp; &nbsp;<i>X</i><sup>&nbsp;<i>N</i></sup>&nbsp;=&nbsp;<i>X</i>&#183;<i>X</i><sup>&nbsp;<i>N</i>&#150;1</sup> при <i>нечетных</i> <i>N</i>&nbsp;&gt;&nbsp;0,<br><i>X</i><sup>&nbsp;<i>N</i></sup>&nbsp;=&nbsp;1/<i>X</i><sup>&nbsp;&#150;<i>N</i></sup> при <i>N</i>&nbsp;&lt;&nbsp;0</center><p class="hntc">(<i>X</i>&nbsp;<font face="Symbol">№</font>&nbsp;0&nbsp;&#151; вещественное число, <i>N</i>&nbsp;&#151; целое; в&nbsp;формуле для четных&nbsp;<i>N</i> должна использоваться операция <i>целочисленного деления</i>). С&nbsp;помощью этой функции найти значения <i>X</i><sup>&nbsp;<i>N</i></sup> для данного&nbsp;<i>X</i> при&nbsp;пяти данных значениях&nbsp;<i>N</i>.</p>
<p class="tsk"><font face="Arial">Recur4</font>. Описать рекурсивную функцию Fib1(<i>N</i>) целого типа, вычисляющую <i>N</i>-й элемент последовательности <i>чисел Фибоначчи</i> (<i>N</i>&nbsp;&#151; целое число): </p><center><i>F</i><sub>1</sub>&nbsp;=&nbsp;<i>F</i><sub>2</sub>&nbsp;=&nbsp;1, &nbsp; &nbsp; &nbsp; &nbsp;<i>F</i><sub><i>K</i></sub>&nbsp;=&nbsp;<i>F</i><sub><i>K</i>&#150;2</sub>&nbsp;+&nbsp;<i>F</i><sub><i>K</i>&#150;1</sub>, &nbsp; &nbsp;<i>K</i>&nbsp;=&nbsp;3,&nbsp;4,&nbsp;&#133;&nbsp;.</center><p class="hntc">С&nbsp;помощью этой функции найти пять чисел Фибоначчи с&nbsp;данными номерами, и&nbsp;вывести эти&nbsp;числа вместе с&nbsp;количеством рекурсивных вызовов функции Fib1, потребовавшихся для&nbsp;их&nbsp;нахождения.</p>
<p class="tsk"><font face="Arial">Recur5</font>. Описать рекурсивную функцию Fib2(<i>N</i>) целого типа, вычисляющую <i>N</i>-й элемент последовательности <i>чисел Фибоначчи</i> (<i>N</i>&nbsp;&#151; целое число): </p><center><i>F</i><sub>1</sub>&nbsp;=&nbsp;<i>F</i><sub>2</sub>&nbsp;=&nbsp;1, &nbsp; &nbsp; &nbsp; &nbsp;<i>F</i><sub><i>K</i></sub>&nbsp;=&nbsp;<i>F</i><sub><i>K</i>&#150;2</sub>&nbsp;+&nbsp;<i>F</i><sub><i>K</i>&#150;1</sub>, &nbsp; &nbsp;<i>K</i>&nbsp;=&nbsp;3,&nbsp;4,&nbsp;&#133;&nbsp;.</center><p class="hntc">Считать, что&nbsp;номер&nbsp;<i>N</i> не&nbsp;превосходит&nbsp;20. Для&nbsp;уменьшения количества рекурсивных вызовов по&nbsp;сравнению с&nbsp;функцией Fib1 (см.&nbsp;задание Recur4) создать вспомогательный массив для&nbsp;хранения <i>уже&nbsp;вычисленных</i> чисел Фибоначчи и&nbsp;обращаться к&nbsp;нему при&nbsp;выполнении функции Fib2. С&nbsp;помощью функции Fib2 найти пять чисел Фибоначчи с&nbsp;данными номерами.</p>
<p class="tsk"><font face="Arial">Recur6</font>. Описать рекурсивную функцию Combin1(<i>N</i>,&nbsp;<i>K</i>) целого типа, находящую <i>C</i>(<i>N</i>,&nbsp;<i>K</i>)&nbsp;&#151; <i>число сочетаний</i> из&nbsp;<i>N</i>&nbsp;элементов по&nbsp;<i>K</i>&nbsp;&#151; с&nbsp;помощью рекуррентного соотношения: </p><center><i>C</i>(<i>N</i>,&nbsp;0)&nbsp;=&nbsp;C(<i>N</i>,&nbsp;<i>N</i>)&nbsp;=&nbsp;1,<br><i>C</i>(<i>N</i>,&nbsp;<i>K</i>)&nbsp;=&nbsp;<i>C</i>(<i>N</i>&nbsp;&#150;&nbsp;1,&nbsp;<i>K</i>)&nbsp;+&nbsp;<i>C</i>(<i>N</i>&nbsp;&#150;&nbsp;1,&nbsp;<i>K</i>&nbsp;&#150;&nbsp;1) &nbsp; &nbsp;при 0&nbsp;&lt;&nbsp;<i>K</i>&nbsp;&lt;&nbsp;<i>N</i>.</center><p class="hntc">Параметры функции&nbsp;&#151; целые числа; <i>N</i>&nbsp;&gt;&nbsp;0, 0&nbsp;<font face="Symbol">Ј</font>&nbsp;<i>K</i>&nbsp;<font face="Symbol">Ј</font>&nbsp;<i>N</i>. Дано число&nbsp;<i>N</i> и&nbsp;пять различных значений&nbsp;<i>K</i>. Вывести числа&nbsp;<i>C</i>(<i>N</i>,&nbsp;<i>K</i>) вместе с&nbsp;количеством рекурсивных вызовов функции Combin1, потребовавшихся для&nbsp;их&nbsp;нахождения.</p>
<p class="tsk"><font face="Arial">Recur7</font>. Описать рекурсивную функцию Combin2(<i>N</i>,&nbsp;<i>K</i>) целого типа, находящую <i>C</i>(<i>N</i>,&nbsp;<i>K</i>)&nbsp;&#151; <i>число сочетаний</i> из&nbsp;<i>N</i>&nbsp;элементов по&nbsp;<i>K</i>&nbsp;&#151; с&nbsp;помощью рекуррентного соотношения: </p><center><i>C</i>(<i>N</i>,&nbsp;0)&nbsp;=&nbsp;C(<i>N</i>,&nbsp;<i>N</i>)&nbsp;=&nbsp;1,<br><i>C</i>(<i>N</i>,&nbsp;<i>K</i>)&nbsp;=&nbsp;<i>C</i>(<i>N</i>&nbsp;&#150;&nbsp;1,&nbsp;<i>K</i>)&nbsp;+&nbsp;<i>C</i>(<i>N</i>&nbsp;&#150;&nbsp;1,&nbsp;<i>K</i>&nbsp;&#150;&nbsp;1) &nbsp; &nbsp;при 0&nbsp;&lt;&nbsp;<i>K</i>&nbsp;&lt;&nbsp;<i>N</i>.</center><p class="hntc">Параметры функции&nbsp;&#151; целые числа; <i>N</i>&nbsp;&gt;&nbsp;0, 0&nbsp;<font face="Symbol">Ј</font>&nbsp;<i>K</i>&nbsp;<font face="Symbol">Ј</font>&nbsp;<i>N</i>. Считать, что&nbsp;параметр&nbsp;<i>N</i> не&nbsp;превосходит&nbsp;20. Для&nbsp;уменьшения количества рекурсивных вызовов по&nbsp;сравнению с&nbsp;функцией Combin1 (см.&nbsp;задание Recur6) описать вспомогательный двумерный массив для&nbsp;хранения <i>уже&nbsp;вычисленных</i> чисел <i>C</i>(<i>N</i>,&nbsp;<i>K</i>) и&nbsp;обращаться к&nbsp;нему при&nbsp;выполнении функции Combin2. С&nbsp;помощью функции Combin2 найти числа <i>C</i>(<i>N</i>,&nbsp;<i>K</i>) для&nbsp;данного значения&nbsp;<i>N</i> и&nbsp;пяти различных значений&nbsp;<i>K</i>.</p>
<p class="tsk"><font face="Arial">Recur8</font>. Описать рекурсивную функцию RootK(<i>X</i>,&nbsp;<i>K</i>,&nbsp;<i>N</i>) вещественного типа, находящую приближенное значение корня <i>K</i>-й&nbsp;степени из&nbsp;числа&nbsp;<i>X</i> по&nbsp;формуле: </p><center><i>Y</i><sub>0</sub>&nbsp;=&nbsp;1, &nbsp; &nbsp; &nbsp; &nbsp;<i>Y</i><sub><i>N</i>+1</sub>&nbsp;=&nbsp;<i>Y</i><sub><i>N</i></sub>&nbsp;&#150;&nbsp;(<i>Y</i><sub><i>N</i></sub>&nbsp;&#150;&nbsp;<i>X</i>/(<i>Y</i><sub><i>N</i></sub>)<sup><i>K</i>&#150;1</sup>)/<i>K</i>,</center><p class="hntc">где <i>Y</i><sub><i>N</i></sub> обозначает RootK(<i>X</i>,&nbsp;<i>K</i>,&nbsp;<i>N</i>) при&nbsp;фиксированных&nbsp;<i>X</i> и&nbsp;<i>K</i>. Параметры функции: <i>X</i>&nbsp;(&gt;&nbsp;0)&nbsp;&#151; вещественное число, <i>K</i>&nbsp;(&gt;&nbsp;1) и&nbsp;<i>N</i>&nbsp;(&gt;&nbsp;0)&nbsp;&#151; целые. С&nbsp;помощью функции RootK найти для данного числа&nbsp;<i>X</i> приближенные значения его&nbsp;корня <i>K</i>-й&nbsp;степени при&nbsp;шести данных значениях&nbsp;<i>N</i>.</p>
<p class="tsk"><font face="Arial">Recur9</font>. Описать рекурсивную функцию NOD(<i>A</i>,&nbsp;<i>B</i>) целого типа, находящую <i>наибольший</i> <i>общий делитель</i> (НОД) двух целых положительных чисел&nbsp;<i>A</i> и&nbsp;<i>B</i>, используя <i>алгоритм Евклида</i>:</p><center>НОД(<i>A</i>,&nbsp;<i>B</i>)&nbsp;=&nbsp;НОД(<i>B</i>, <i>A</i>&nbsp;mod&nbsp;<i>B</i>), &nbsp; &nbsp;если <i>B</i>&nbsp;<font face="Symbol">№</font>&nbsp;0; &nbsp; &nbsp; &nbsp; &nbsp;НОД(<i>A</i>,&nbsp;0)&nbsp;=&nbsp;<i>A</i>.</center><p class="hntc">С&nbsp;помощью этой функции найти НОД(<i>A</i>,&nbsp;<i>B</i>), НОД(<i>A</i>,&nbsp;<i>C</i>), НОД(<i>A</i>,&nbsp;<i>D</i>), если даны числа&nbsp;<i>A</i>, <i>B</i>, <i>C</i>,&nbsp;<i>D</i>.</p>
<p class="tsk"><font face="Arial">Recur10</font>. Описать рекурсивную функцию DigitSum(<i>K</i>) целого типа, которая находит сумму цифр целого числа&nbsp;<i>K</i>, не&nbsp;используя оператор цикла. С&nbsp;помощью этой функции найти суммы цифр для пяти данных целых чисел.</p>
<p class="tsk"><font face="Arial">Recur11</font>. Описать рекурсивную функцию MaxInt(<i>A</i>, <i>N</i>) целого типа, которая находит максимальный элемент целочисленного массива&nbsp;<i>A</i> размера&nbsp;<i>N</i> (1&nbsp;<font face="Symbol">Ј</font>&nbsp;<i>N</i>&nbsp;<font face="Symbol">Ј</font>&nbsp;10), не&nbsp;используя оператор цикла. С&nbsp;помощью этой функции найти максимальные элементы массивов&nbsp;<i>A</i>, <i>B</i>,&nbsp;<i>C</i> размера&nbsp;<i>N</i><sub><i>A</i></sub>, <i>N</i><sub><i>B</i></sub>,&nbsp;<i>N</i><sub><i>C</i></sub> соответственно.</p>
<p class="tsk"><font face="Arial">Recur12</font>. Описать рекурсивную функцию DigitCount(<i>S</i>) целого типа, которая находит количество цифр в&nbsp;строке&nbsp;<i>S</i>, не&nbsp;используя оператор цикла. С&nbsp;помощью этой функции найти количество цифр в&nbsp;каждой из пяти данных строк.</p>
<p class="tsk"><font face="Arial">Recur13</font>. Описать рекурсивную функцию Palindrom(<i>S</i>) логического типа, возвращающую True, если строка&nbsp;<i>S</i> является <i>палиндромом</i> (то&nbsp;есть читается одинаково слева направо и&nbsp;справа налево), и&nbsp;False в&nbsp;противном случае. Оператор цикла в&nbsp;теле функции не&nbsp;использовать. Вывести значения функции Palindrom для&nbsp;пяти данных строк.</p>
<p class="cmt"><h2>Разбор выражений</h2></p>
<p class="cmt">Во всех заданиях данного пункта предполагается, что&nbsp;исходные строки, определяющие выражения, не&nbsp;содержат пробелов. При&nbsp;выполнении заданий не&nbsp;следует использовать оператор цикла.</p>
<p class="tsk"><font face="Arial">Recur14</font>. Вывести значение целочисленного выражения, заданного в&nbsp;виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом: </p><center><table><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; | &lt;выражение&gt;&nbsp;+&nbsp;&lt;цифра&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;выражение&gt;&nbsp;&#150;&nbsp;&lt;цифра&gt;</table></center>
<p class="tsk"><font face="Arial">Recur15</font>. Вывести значение целочисленного выражения, заданного в&nbsp;виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом: </p><center><table><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;терм&gt; | &lt;выражение&gt;&nbsp;+&nbsp;&lt;терм&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;выражение&gt;&nbsp;&#150;&nbsp;&lt;терм&gt;<tr><td align=left>&lt;терм&gt;      <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; | &lt;терм&gt;&nbsp;*&nbsp;&lt;цифра&gt;</table></center>
<p class="tsk"><font face="Arial">Recur16</font>. Вывести значение целочисленного выражения, заданного в&nbsp;виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом: </p><center><table><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;терм&gt; | &lt;выражение&gt;&nbsp;+&nbsp;&lt;терм&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;выражение&gt;&nbsp;&#150;&nbsp;&lt;терм&gt;<tr><td align=left>&lt;терм&gt;      <td align=center><tt>::=</tt> <td align=left>&lt;элемент&gt; | &lt;терм&gt;&nbsp;*&nbsp;&lt;элемент&gt;<tr><td align=left>&lt;элемент&gt;   <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; | (&lt;выражение&gt;)</table></center>
<p class="tsk"><font face="Arial">Recur17*</font>. Вывести значение целочисленного выражения, заданного в&nbsp;виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом: </p><center><table><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>(&lt;выражение&gt;&lt;знак&gt;&lt;выражение&gt;)<tr><td align=left>&lt;знак&gt;      <td align=center><tt>::=</tt> <td align=left>+ | &#150; | *</table></center>
<p class="tsk"><font face="Arial">Recur18*</font>. Проверить правильность выражения, заданного в&nbsp;виде непустой строки&nbsp;<i>S</i> (выражение определяется по&nbsp;тем&nbsp;же правилам, что&nbsp;и&nbsp;в&nbsp;задании Recur17). Если выражение составлено правильно, то&nbsp;вывести True, иначе вывести False.</p>
<p class="tsk"><font face="Arial">Recur19</font>. Проверить правильность выражения, заданного в&nbsp;виде непустой строки&nbsp;<i>S</i> (выражение определяется по&nbsp;тем&nbsp;же правилам, что&nbsp;и&nbsp;в&nbsp;задании Recur17). Если выражение составлено правильно, то&nbsp;вывести&nbsp;0, в&nbsp;противном случае вывести номер первого ошибочного, лишнего или&nbsp;недостающего символа в&nbsp;строке&nbsp;<i>S</i>.</p>
<p class="tsk"><font face="Arial">Recur20</font>. Вывести значение целочисленного выражения, заданного в&nbsp;виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом (функция&nbsp;M возвращает максимальный из&nbsp;своих параметров, а&nbsp;функция&nbsp;m&nbsp;&#151; минимальный): </p><center><table><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; | M(&lt;выражение&gt;&nbsp;,&nbsp;&lt;выражение&gt;) | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>m(&lt;выражение&gt;&nbsp;,&nbsp;&lt;выражение&gt;)</table></center>
<p class="tsk"><font face="Arial">Recur21</font>. Вывести значение логического выражения, заданного в&nbsp;виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом (&#171;T&#187;&nbsp;&#151; True, &#171;F&#187;&nbsp;&#151; False): </p><center><table><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>T | F | And(&lt;выражение&gt;&nbsp;,&nbsp;&lt;выражение&gt;) | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>Or(&lt;выражение&gt;&nbsp;,&nbsp;&lt;выражение&gt;)</table></center>
<p class="tsk"><font face="Arial">Recur22</font>. Вывести значение целочисленного выражения, заданного в&nbsp;виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом (функция&nbsp;M возвращает максимальный из&nbsp;своих параметров, а&nbsp;функция&nbsp;m&nbsp;&#151; минимальный): </p><center><table><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; | M(&lt;параметры&gt;) | m(&lt;параметры&gt;)<tr><td align=left>&lt;параметры&gt; <td align=center><tt>::=</tt> <td align=left>&lt;выражение&gt; | &lt;выражение&gt;&nbsp;,&nbsp;&lt;параметры&gt;</table></center>
<p class="tsk"><font face="Arial">Recur23</font>. Вывести значение логического выражения, заданного в&nbsp;виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом (&#171;T&#187;&nbsp;&#151; True, &#171;F&#187;&nbsp;&#151; False): </p><center><table><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>T | F | And(&lt;параметры&gt;) | Or(&lt;параметры&gt;)<tr><td align=left>&lt;параметры&gt; <td align=center><tt>::=</tt> <td align=left>&lt;выражение&gt; | &lt;выражение&gt;&nbsp;,&nbsp;&lt;параметры&gt;</table></center>
<p class="tsk"><font face="Arial">Recur24</font>. Вывести значение логического выражения, заданного в&nbsp;виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом (&#171;T&#187;&nbsp;&#151; True, &#171;F&#187;&nbsp;&#151; False): </p><center><table><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>T | F | And(&lt;параметры&gt;) | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>Or(&lt;параметры&gt;) | Not(&lt;выражение&gt;)<tr><td align=left>&lt;параметры&gt; <td align=center><tt>::=</tt> <td align=left>&lt;выражение&gt; | &lt;выражение&gt;&nbsp;,&nbsp;&lt;параметры&gt;</table></center>
<p class="cmt"><h2>Перебор с возвратом</h2></p>
<p class="tsk"><font face="Arial">Recur25*</font>. Дано дерево глубины&nbsp;<i>N</i>, каждая внутренняя вершина которого имеет <i>K</i>&nbsp;(&lt;&nbsp;10) непосредственных потомков (нумеруются от&nbsp;1 до&nbsp;<i>K</i>). Корень дерева имеет номер&nbsp;0. Записать в&nbsp;текстовый файл с&nbsp;данным именем все возможные пути, ведущие от&nbsp;корня к&nbsp;листьям. Перебирать пути, начиная с&nbsp;&#171;самого левого&#187; и&nbsp;заканчивая &#171;самым правым&#187; (при&nbsp;этом первыми заменять конечные элементы пути).</p>
<p class="tsk"><font face="Arial">Recur26</font>. Дано дерево глубины&nbsp;<i>N</i>, каждая внутренняя вершина которого имеет <i>K</i>&nbsp;(&lt;&nbsp;10) непосредственных потомков (нумеруются от&nbsp;1 до&nbsp;<i>K</i>). Корень дерева имеет номер&nbsp;0. Записать в&nbsp;текстовый файл с&nbsp;данным именем все&nbsp;пути, ведущие от&nbsp;корня к&nbsp;листьям и&nbsp;удовлетворяющие следующему условию: никакие соседние элементы пути не&nbsp;нумеруются одной и&nbsp;той&nbsp;же цифрой. Порядок перебора путей такой&nbsp;же, как&nbsp;в&nbsp;задании Recur25.</p>
<p class="tsk"><font face="Arial">Recur27</font>. Дано дерево глубины&nbsp;<i>N</i> (<i>N</i>&nbsp;&#151; четное), каждая внутренняя вершина которого имеет 2&nbsp;непосредственных потомка: <i>A</i> с&nbsp;весом&nbsp;1 и&nbsp;<i>B</i> с&nbsp;весом&nbsp;&#150;1. Корень дерева&nbsp;<i>C</i> имеет вес&nbsp;0. Записать в&nbsp;текстовый файл с&nbsp;данным именем все&nbsp;пути от&nbsp;корня к&nbsp;листьям, удовлетворяющие следующему условию: суммарный вес элементов пути равен&nbsp;0. Порядок перебора путей такой&nbsp;же, как&nbsp;в&nbsp;задании Recur25.</p>
<p class="tsk"><font face="Arial">Recur28</font>. Дано дерево глубины&nbsp;<i>N</i> того&nbsp;же&nbsp;типа, что&nbsp;и&nbsp;в&nbsp;задании Recur27. Записать в текстовый файл с данным именем все&nbsp;пути от&nbsp;корня к&nbsp;листьям, удовлетворяющие следующему условию: суммарный вес элементов для&nbsp;любого начального отрезка пути неотрицателен. Порядок перебора путей такой&nbsp;же, как&nbsp;в&nbsp;задании Recur25.</p>
<p class="tsk"><font face="Arial">Recur29</font>. Дано дерево глубины&nbsp;<i>N</i>, каждая внутренняя вершина которого имеет 3&nbsp;непосредственных потомка: <i>A</i> с&nbsp;весом&nbsp;1, <i>B</i> с&nbsp;весом&nbsp;0 и&nbsp;<i>C</i> с&nbsp;весом&nbsp;&#150;1. Корень дерева&nbsp;<i>D</i> имеет вес&nbsp;0. Записать в&nbsp;текстовый файл с&nbsp;данным именем все пути от&nbsp;корня к&nbsp;листьям, удовлетворяющие следующим условиям: суммарный вес элементов для&nbsp;любого начального отрезка пути неположителен, а&nbsp;суммарный вес всех элементов пути равен&nbsp;0. Порядок перебора путей такой&nbsp;же, как&nbsp;в&nbsp;задании Recur25.</p>
<p class="tsk"><font face="Arial">Recur30</font>. Дано дерево глубины&nbsp;<i>N</i> того&nbsp;же&nbsp;типа, что&nbsp;и&nbsp;в&nbsp;задании Recur29. Записать в&nbsp;текстовый файл с&nbsp;данным именем все пути от&nbsp;корня к&nbsp;листьям, удовлетворяющие следующим условиям: никакие соседние элементы пути не&nbsp;обозначаются одной и&nbsp;той&nbsp;же буквой, а&nbsp;суммарный вес всех элементов пути равен&nbsp;0. Порядок перебора путей такой&nbsp;же, как&nbsp;в&nbsp;задании Recur25.</p>
<hr noshade><div align=right><font size=-1>Дата генерации страницы: 22.03.2005.</font></div></body></html>
